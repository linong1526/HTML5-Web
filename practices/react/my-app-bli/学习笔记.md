# 创建一个react项目
1.进行局部安装
```ssh
 npx create-react-app my-app-bli
 cd my-app-bli
 npm start
```
生成目录：
├──README.md             使用方法的文档
├──node_modules          所有的依赖安装的目录
├──package-lock.json     锁定安装时的包的版本号,保证团队的依赖能保证一致。
├──package.json         
├──public                静态公共目录
└──src                   开发用的源代码目录

出现如下信息，表示安装成功:
```ssh 
PS F:\学习更多\githubLearn\HTML5-Web\react\practices> npx create-react-app my-app-bli
Need to install the following packages:
  create-react-app
Ok to proceed? (y)
npm WARN deprecated tar@2.2.2: This version of tar is no longer supported, and will not receive security updates. Please upgrade asap.

Creating a new React app in F:\学习更多\githubLearn\HTML5-Web\react\practices\my-app-bli.

Installing packages. This might take a couple of minutes.
Installing react, react-dom, and react-scripts with cra-template...


added 1393 packages in 3m

Installing template dependencies using npm...
npm WARN deprecated source-map-resolve@0.6.0: See https://github.com/lydell/source-map-resolve#deprecated

added 52 packages in 10s
Removing template package using npm...


removed 1 package in 4s

Success! Created my-app-bli at F:\学习更多\githubLearn\HTML5-Web\react\practices\my-app-bli
Inside that directory, you can run several commands:

  npm start
    Starts the development server.

  npm run build
    Bundles the app into static files for production.

  npm test
    Starts the test runner.

  npm run eject
    Removes this tool and copies build dependencies, configuration files
    and scripts into the app directory. If you do this, you can’t go back!

We suggest that you begin by typing:

  cd my-app-bli
  npm start

Happy hacking!

```
2. 删除`src`下的文件，重新新建一个`index.js`文件

```js 
// 从 react 的包当中引入了 React。只要你要写 React.js 组件就必须引入React, 因为react里有 一种语法叫JSX，稍后会讲到JSX，要写JSX，就必须引入
React import React from 'react' 
// ReactDOM 可以帮助我们把 React 组件渲染到页面上去，没有其它的作用了。它是从 react-dom 中 引入的，而不是从 react 引入。 
import ReactDOM from 'react-dom' 
// ReactDOM里有一个render方法，功能就是把组件渲染并且构造 DOM 树，然后插入到页面上某个特定的 元素上 
ReactDOM.render( 
  // 这里就比较奇怪了，它并不是一个字符串，看起来像是纯 HTML 代码写在 JavaScript 代码里面。语 法错误吗？这并不是合法的 JavaScript 代码, “在 JavaScript 写的标签的”语法叫 JSX- JavaScript XML。
   <h1>欢迎进入React的世界</h1>, 
   // 渲染到哪里 
   document.getElementById('root') 
)

```
# JSX语法和组件
## 体验JSX语法
```js
import React from 'react';
import ReactDOM from 'react-dom';

//写法一：
ReactDOM.render(
  <div>
    <h1>1111</h1>
    <ul>
      <li>111</li>
      <li>111</li>
      <li>111</li>
    </ul>
  </div>,
  document.getElementById('root')
)
// 写法二:与写法一等效
ReactDOM.render(
React.createElement('div',{id:'app',className:'bbb'},'内容'),
  document.getElementById('root')
)

```
## class组件
* ES6写法
  ./scr/inde.js
  ```js
  import React from 'react';
  import ReactDOM from 'react-dom';
  import './01-base/01-class' // 引入自动加载 

  ReactDOM.render(
      React.createElement('div',{id:'app',className:'bbb'},'内容'),
      document.getElementById('root')
  )

  ```
  ./src/0-base/01-class
  ```js
  // ES6写法
  class Test{
    constructor(){
      this.a = 1
    }
    testa(){
      console.log("testa")
    } 
  }
  class ChildTest extends Test{
    testb(){
      console.log("testb")
    }
  }
  // var obj = new Test()
  // obj.testa() // 执行方法 输出testa
  // console.log(obj.a) // 打印属性  1

  var obj = new ChildTest()
  obj.testa() // 执行方法 输出 testa
  console.log(obj.a) // 输出 1

  ```
* ES7 写法
./src/index.js
```js 
import React from 'react';
import ReactDOM from 'react-dom';
import App from './01-base/01-class'
ReactDOM.render(
    <App />,
    document.getElementById('root')
)

```
  ./src/0-base/01-class
```js
// ES7 
// import React from 'react';
// class App extends React.Component{
//   render(){
//     return (
//       <div>1111</div>
//     )
//   }
// } 

import React, { Component } from 'react'
class App extends Component{
render(){
  // renturn () 用括号括起来，表示式回车下的属于一部分的内容
  return (
      <div>
        <h1>1111</h1>
        <ul>
          <li>111</li>
          <li>111</li>
          <li>111</li>
        </ul>
      </div>
  )
}
} 
export default App

```
* 复用组件(推荐)
组件 必须大写开头，否则会报错
为了让代码编写更规范，我们可以下载 插件 `ES7+ React/Redux/React-Native/JS snippets`
./src/index.js
```js
import React from 'react';
import ReactDOM from 'react-dom';
import App from './01-base/01-class'
ReactDOM.render(
    <App />,
    document.getElementById('root')
)
```
  ./src/0-base/01-class
  ```js 
import React, { Component } from 'react'
export default class App extends Component {
  render() {
    return (
      <div>01-class</div>
    )
  }
}

  ```
## 函数组件
16.8之前  无状态组件
16.8   react hooks 
./src/index/j
```js
import React from 'react';
import ReactDOM from 'react-dom';
import App from './01-base/02-fun'
ReactDOM.render(
    <App />,
    document.getElementById('root')
)
```
./src/01-base/02-fun.js
```js
function App(){
  return (
    <div>function Component</div>
  )
}

export default App

```
## 组件嵌套
./src/index.js
```js
import React from 'react';
import ReactDOM from 'react-dom';
import App from './01-base/03-Nesting.js'
ReactDOM.render(
    <App />,
    document.getElementById('root')
)
```
./src/01-base/03-Nesting.js
```js
import React, { Component } from 'react'
class Child extends Component{
  render(){
    return (
      <div>Child Component</div>
    )
  }
}
class Navbar extends Component {
  render(){
    return (
    <div>
      Navbar
      <Child></Child>
    </div>
    )
  }
}
function Swiper(){
  return <div>Swiper</div>
}
// const Tabbar =()=><div>Tabbar</div>
const Tabbar =()=>{
  return <div>Tabbar</div>
}

export default class App extends Component {
  render() {
    return (
      <div>
        {/* 想要在 Navbar 里嵌套子组件， 需要 在Navbar组件放入一个子组件Child，在子组件里写内容 ，而不是在放在<Navbar>标签中*/}
        <Navbar></Navbar>
        <Swiper></Swiper>
        <Tabbar></Tabbar>
      </div>
    )
  }
}

```
## 组件样式
./src/index.js
```js
import React from 'react';
import ReactDOM from 'react-dom';
import './01-base/css/04.css' // y引入外部css样式
import App from './01-base/04-style.js'
ReactDOM.render(
    <App />,
    document.getElementById('root')
)

```
./src/01-base/04-style.js
```js
import React, { Component } from 'react'

export default class App extends Component {
  render() {
    var myname = 'Iekaki'
    // 此样式写仅为演示，项目中不推荐这样使用
    var obj ={
      background:'red', // 需要加入引号
      backgroundColor:'green', // 单一属性需要 写成驼峰写法
      fontSize:'10px'
    }
    return (
      <div>
        {/* 模板语法 */}
        {10+20}
        {/* 变量 */}
        {10+20}- {myname}
        {/* 三目运算 ，加减乘除 ，字符串*/}
        {10>20?'aaa':'bbb'}
        {/* style={} 需要放入一个对象 */}
        <div style={{background:"red"}}>111111</div>
        <div style={obj}>111111</div>
        {/* 属性需要驼峰写法 css样式 需要引入外部css文件*/}
        {/* 另外 class ,for是react的关键字 不可以使用 
        <div class='active'>111111</div>
        <label for='username'>用户名:</label>
        */}
        <div className='active'>111111</div>
        <div id='active'>111111</div>
        <label htmlFor=''>用户名:</label>
        <label htmlFor='username'>用户名:</label>
          <input type="text" id='username'></input>
        
      </div>
    )
  }
}
```
## 事件对象
###  使用
./src/index.js
```js
import React from 'react';
import ReactDOM from 'react-dom';
import App from './01-base/05-event.js'
ReactDOM.render(
    <App />,
    document.getElementById('root')
)

```
./src/01-base/05-event.js
```js
import React, { Component } from 'react'

export default class App extends Component {
  render() {
    return (
      <div>
        05-event
        <input />
        {/* on + 事件类型（注意要写驼峰） */}
        <button onMouseEnter={()=>{
          console.log('onMouseEnter')
        }}>onMouseEnter</button>
        <button onMouseOver={()=>{
          console.log('onMouseEnter')
        }}>onMouseOver</button>

        {/* 无过多逻辑 推荐用法 */}
        <button onClick={()=>{
          console.log('click1')
        }}>add1</button>

        {/* 可以定义在外边  不要加() 画蛇添足 <button onClick={this.handleClick()}></button>*/}
        <button onClick={this.handleClick2}>dd2</button>
        <button onClick={this.handleClick3}>add3</button> 
        {/*组合  逻辑过多 推荐写法*/}
        <button onClick={()=>{
          this.handleClick4()
        }}>add4</button>     
        </div>
    )
  }
  handleClick2(){
    console.log('click2')
  }
  handleClick3=()=>{
    console.log('click3')
  }
  handleClick4=()=>{
    console.log('click3')
  }
}


```
### 事件绑定
./src/01-base/06-eventbind.js
```js
import React, { Component } from 'react'
export default class App extends Component {
  a = 1000
  render() {
    return (
      <div>
        05-event
        <input />
        {/* on + 事件类型（注意要写驼峰） */}
        <button onClick={()=>{
          console.log('click1',this.a)
        }}>add1</button>
        <button onClick={this.handleClick2}>add3</button> 
        <button onClick={this.handleClick.bind(this)}>add-bind不推荐这种写法</button> 
        <button onClick={this.handleClick3}>add3</button> 
        <button onClick={this.handleClick3evt}>SyntheticBaseEvent</button> 
        <button onClick={()=>{
          this.handleClick4()
        }}>add4</button>     
        </div>
    )
  } 
  handleClick2(){
    console.log('click2',this) // click2  undefined
  }
  handleClick(){
    console.log('click2',this.a) // click2  100  绑定 App 的实例
  }
  
  handleClick3=()=>{
    console.log('click3',this.a) // click3  100 箭头函数箭头函数`的this指向指向上下文，所以永久能拿到当前组件实例的this指向
  }
  handleClick3evt=(evt)=>{
    console.log('handleClick3evt',evt,evt.target) // click3  SyntheticBaseEvent  <button>SyntheticBaseEvent</button>
  }
  handleClick4=()=>{
    console.log('click4',this.a) // click4 100 箭头函数，还可以传参
  }
}
/**
 * React 并不会真正的绑定到每一个具体 <> 的元素上，而是采用事件代理的模式:
*/

  // this 的指向 复习
  var obj1 ={
    name:'obj1',
    getName(){
      console.log('obj1')
    }
  }
  var obj2 ={
    name:'obj1',
    getName(){
      console.log('obj1')
    }
  }
  obj1.getName() // obj1
  obj2.getName() // obj2
  obj1.getName.call(obj2) // obj2
  obj1.getName.apply(obj2) // obj2
  obj1.getName.bind(obj2) // 没有打印内容
  obj1.getName.bind(obj2)()  // 自动执行 obj2


```
## Ref 应用
./src/index.js
```js
import React from 'react';
import ReactDOM from 'react-dom';
import App from './01-base/07-ref.js'
ReactDOM.render(
  // 严格模式
  <React.StrictMode>
    <App />
  </React.StrictMode>,
    // <App />,
    document.getElementById('root')
)

```
### 以前的写法
./src/01-base/07-ref.js
```js
import React, { Component } from 'react'
export default class App extends Component {
  render() {
    return (
      <div>
        Ref的应用
        <input ref="mytext"></input>
        <button onClick={()=>{
          // 获取Dom/组件 this.refs.xxx 即将被弃用 严格模式下会报错
          console.log('click',this.refs.mytext,this.refs.mytext.value) // click <input /> 输入的内容
        }}></button>
      </div>
    )
  }
}

```
### 现在的写法
```js
import React, { Component } from 'react'
export default class App extends Component {
  myref= React.createRef() // 返回一个ref对象
  render() {
    return (
      <div>
        Ref的应用
        <input ref={this.myref}></input>
        <button onClick={()=>{
          // 使用 React.createRef()
          console.log("click",this.myref,this.myref.value) // this.myref----{current:input,[[Proptotype]]: Object} 
        }}>点击</button>
        <button onClick={this.handleClick}></button>
        <button onClick={this.handleClick2.bind(this)}></button>
        <button onClick={this.handleClick3}></button>
      </div>
    )
  }
  handleClick(){
    // 这里的 this指向 div 不是 App
    console.log("handleClick ",this.myref,this.myref.value) // undefined
  }
  handleClick2(){
    // 这里的 this指向 App
    console.log("handleClick2 ",this.myref,this.myref.value) // this.myref----{current:input,[[Proptotype]]: Object} 
  }
  handleClick3=()=>{
    // 这里的 this指向 App
    console.log("handleClick3 ",this.myref,this.myref.value) // this.myref----{current:input,[[Proptotype]]: Object} 
  }
}

```

# 组件的数据挂载方式
## state状态
./src/01-base/08-state.js
```js
import React, { Component } from 'react'

export default class App extends Component {
  // state={
  //   mytext:"收藏",
  //   myShow:true
  // }
  // 还可以这样定义state
  constructor(){
    super()
    this.state={
      mytext:"收藏",
      myShow:true,
      myname:'Iekika'
    }
  }
  render() {
    return (
      <div>
        App
        <button onClick={()=>{
          // this.state.mytext = "取消" // 不可以直接修改 state状态
          // 需要这样修改 间接修改
          this.setState({
            mytext:"取消收藏",
            // setState 可以合并修改的状态
            myname:'kkkkk'
          })
        }}>{this.state.mytext}</button>
        {/* 项目中更推荐这种写法 */}
        <button onClick={()=>{
          this.setState({
            myShow:!this.state.myShow
          })
          // 需要对接接口时
          if(this.state.myShow){
            console.log('收藏的逻辑')
          }else{
            console.log("取消收藏的逻辑")
          }
        }}>{this.state.mytext ? "收藏": "取消收藏"}</button>
      </div>
    )
  }
}

```
## 渲染数据
./src/01-base/09-render.js
```js
# 创建一个react项目
1.进行局部安装
```ssh
 npx create-react-app my-app-bli
 cd my-app-bli
 npm start
```
生成目录：
├──README.md             使用方法的文档
├──node_modules          所有的依赖安装的目录
├──package-lock.json     锁定安装时的包的版本号,保证团队的依赖能保证一致。
├──package.json         
├──public                静态公共目录
└──src                   开发用的源代码目录

出现如下信息，表示安装成功:
```ssh 
PS F:\学习更多\githubLearn\HTML5-Web\react\practices> npx create-react-app my-app-bli
Need to install the following packages:
  create-react-app
Ok to proceed? (y)
npm WARN deprecated tar@2.2.2: This version of tar is no longer supported, and will not receive security updates. Please upgrade asap.

Creating a new React app in F:\学习更多\githubLearn\HTML5-Web\react\practices\my-app-bli.

Installing packages. This might take a couple of minutes.
Installing react, react-dom, and react-scripts with cra-template...


added 1393 packages in 3m

Installing template dependencies using npm...
npm WARN deprecated source-map-resolve@0.6.0: See https://github.com/lydell/source-map-resolve#deprecated

added 52 packages in 10s
Removing template package using npm...


removed 1 package in 4s

Success! Created my-app-bli at F:\学习更多\githubLearn\HTML5-Web\react\practices\my-app-bli
Inside that directory, you can run several commands:

  npm start
    Starts the development server.

  npm run build
    Bundles the app into static files for production.

  npm test
    Starts the test runner.

  npm run eject
    Removes this tool and copies build dependencies, configuration files
    and scripts into the app directory. If you do this, you can’t go back!

We suggest that you begin by typing:

  cd my-app-bli
  npm start

Happy hacking!

```
2. 删除`src`下的文件，重新新建一个`index.js`文件

```js 
// 从 react 的包当中引入了 React。只要你要写 React.js 组件就必须引入React, 因为react里有 一种语法叫JSX，稍后会讲到JSX，要写JSX，就必须引入
React import React from 'react' 
// ReactDOM 可以帮助我们把 React 组件渲染到页面上去，没有其它的作用了。它是从 react-dom 中 引入的，而不是从 react 引入。 
import ReactDOM from 'react-dom' 
// ReactDOM里有一个render方法，功能就是把组件渲染并且构造 DOM 树，然后插入到页面上某个特定的 元素上 
ReactDOM.render( 
  // 这里就比较奇怪了，它并不是一个字符串，看起来像是纯 HTML 代码写在 JavaScript 代码里面。语 法错误吗？这并不是合法的 JavaScript 代码, “在 JavaScript 写的标签的”语法叫 JSX- JavaScript XML。
   <h1>欢迎进入React的世界</h1>, 
   // 渲染到哪里 
   document.getElementById('root') 
)

```
# JSX语法和组件
## 体验JSX语法
```js
import React from 'react';
import ReactDOM from 'react-dom';

//写法一：
ReactDOM.render(
  <div>
    <h1>1111</h1>
    <ul>
      <li>111</li>
      <li>111</li>
      <li>111</li>
    </ul>
  </div>,
  document.getElementById('root')
)
// 写法二:与写法一等效
ReactDOM.render(
React.createElement('div',{id:'app',className:'bbb'},'内容'),
  document.getElementById('root')
)

```
## class组件
* ES6写法
  ./scr/inde.js
  ```js
  import React from 'react';
  import ReactDOM from 'react-dom';
  import './01-base/01-class' // 引入自动加载 

  ReactDOM.render(
      React.createElement('div',{id:'app',className:'bbb'},'内容'),
      document.getElementById('root')
  )

  ```
  ./src/0-base/01-class
  ```js
  // ES6写法
  class Test{
    constructor(){
      this.a = 1
    }
    testa(){
      console.log("testa")
    } 
  }
  class ChildTest extends Test{
    testb(){
      console.log("testb")
    }
  }
  // var obj = new Test()
  // obj.testa() // 执行方法 输出testa
  // console.log(obj.a) // 打印属性  1

  var obj = new ChildTest()
  obj.testa() // 执行方法 输出 testa
  console.log(obj.a) // 输出 1

  ```
* ES7 写法
./src/index.js
```js 
import React from 'react';
import ReactDOM from 'react-dom';
import App from './01-base/01-class'
ReactDOM.render(
    <App />,
    document.getElementById('root')
)

```
  ./src/0-base/01-class
```js
// ES7 
// import React from 'react';
// class App extends React.Component{
//   render(){
//     return (
//       <div>1111</div>
//     )
//   }
// } 

import React, { Component } from 'react'
class App extends Component{
render(){
  // renturn () 用括号括起来，表示式回车下的属于一部分的内容
  return (
      <div>
        <h1>1111</h1>
        <ul>
          <li>111</li>
          <li>111</li>
          <li>111</li>
        </ul>
      </div>
  )
}
} 
export default App

```
* 复用组件(推荐)
组件 必须大写开头，否则会报错
为了让代码编写更规范，我们可以下载 插件 `ES7+ React/Redux/React-Native/JS snippets`
./src/index.js
```js
import React from 'react';
import ReactDOM from 'react-dom';
import App from './01-base/01-class'
ReactDOM.render(
    <App />,
    document.getElementById('root')
)
```
  ./src/0-base/01-class
  ```js 
import React, { Component } from 'react'
export default class App extends Component {
  render() {
    return (
      <div>01-class</div>
    )
  }
}

  ```
## 函数组件
16.8之前  无状态组件
16.8   react hooks 
./src/index/j
```js
import React from 'react';
import ReactDOM from 'react-dom';
import App from './01-base/02-fun'
ReactDOM.render(
    <App />,
    document.getElementById('root')
)
```
./src/01-base/02-fun.js
```js
function App(){
  return (
    <div>function Component</div>
  )
}

export default App

```
## 组件嵌套
./src/index.js
```js
import React from 'react';
import ReactDOM from 'react-dom';
import App from './01-base/03-Nesting.js'
ReactDOM.render(
    <App />,
    document.getElementById('root')
)
```
./src/01-base/03-Nesting.js
```js
import React, { Component } from 'react'
class Child extends Component{
  render(){
    return (
      <div>Child Component</div>
    )
  }
}
class Navbar extends Component {
  render(){
    return (
    <div>
      Navbar
      <Child></Child>
    </div>
    )
  }
}
function Swiper(){
  return <div>Swiper</div>
}
// const Tabbar =()=><div>Tabbar</div>
const Tabbar =()=>{
  return <div>Tabbar</div>
}

export default class App extends Component {
  render() {
    return (
      <div>
        {/* 想要在 Navbar 里嵌套子组件， 需要 在Navbar组件放入一个子组件Child，在子组件里写内容 ，而不是在放在<Navbar>标签中*/}
        <Navbar></Navbar>
        <Swiper></Swiper>
        <Tabbar></Tabbar>
      </div>
    )
  }
}

```
## 组件样式
./src/index.js
```js
import React from 'react';
import ReactDOM from 'react-dom';
import './01-base/css/04.css' // y引入外部css样式
import App from './01-base/04-style.js'
ReactDOM.render(
    <App />,
    document.getElementById('root')
)

```
./src/01-base/04-style.js
```js
import React, { Component } from 'react'

export default class App extends Component {
  render() {
    var myname = 'Iekaki'
    // 此样式写仅为演示，项目中不推荐这样使用
    var obj ={
      background:'red', // 需要加入引号
      backgroundColor:'green', // 单一属性需要 写成驼峰写法
      fontSize:'10px'
    }
    return (
      <div>
        {/* 模板语法 */}
        {10+20}
        {/* 变量 */}
        {10+20}- {myname}
        {/* 三目运算 ，加减乘除 ，字符串*/}
        {10>20?'aaa':'bbb'}
        {/* style={} 需要放入一个对象 */}
        <div style={{background:"red"}}>111111</div>
        <div style={obj}>111111</div>
        {/* 属性需要驼峰写法 css样式 需要引入外部css文件*/}
        {/* 另外 class ,for是react的关键字 不可以使用 
        <div class='active'>111111</div>
        <label for='username'>用户名:</label>
        */}
        <div className='active'>111111</div>
        <div id='active'>111111</div>
        <label htmlFor=''>用户名:</label>
        <label htmlFor='username'>用户名:</label>
          <input type="text" id='username'></input>
        
      </div>
    )
  }
}
```
## 事件对象
###  使用
./src/index.js
```js
import React from 'react';
import ReactDOM from 'react-dom';
import App from './01-base/05-event.js'
ReactDOM.render(
    <App />,
    document.getElementById('root')
)

```
./src/01-base/05-event.js
```js
import React, { Component } from 'react'

export default class App extends Component {
  render() {
    return (
      <div>
        05-event
        <input />
        {/* on + 事件类型（注意要写驼峰） */}
        <button onMouseEnter={()=>{
          console.log('onMouseEnter')
        }}>onMouseEnter</button>
        <button onMouseOver={()=>{
          console.log('onMouseEnter')
        }}>onMouseOver</button>

        {/* 无过多逻辑 推荐用法 */}
        <button onClick={()=>{
          console.log('click1')
        }}>add1</button>

        {/* 可以定义在外边  不要加() 画蛇添足 <button onClick={this.handleClick()}></button>*/}
        <button onClick={this.handleClick2}>dd2</button>
        <button onClick={this.handleClick3}>add3</button> 
        {/*组合  逻辑过多 推荐写法*/}
        <button onClick={()=>{
          this.handleClick4()
        }}>add4</button>     
        </div>
    )
  }
  handleClick2(){
    console.log('click2')
  }
  handleClick3=()=>{
    console.log('click3')
  }
  handleClick4=()=>{
    console.log('click3')
  }
}


```
### 事件绑定
./src/01-base/06-eventbind.js
```js
import React, { Component } from 'react'
export default class App extends Component {
  a = 1000
  render() {
    return (
      <div>
        05-event
        <input />
        {/* on + 事件类型（注意要写驼峰） */}
        <button onClick={()=>{
          console.log('click1',this.a)
        }}>add1</button>
        <button onClick={this.handleClick2}>add3</button> 
        <button onClick={this.handleClick.bind(this)}>add-bind不推荐这种写法</button> 
        <button onClick={this.handleClick3}>add3</button> 
        <button onClick={this.handleClick3evt}>SyntheticBaseEvent</button> 
        <button onClick={()=>{
          this.handleClick4()
        }}>add4</button>     
        </div>
    )
  } 
  handleClick2(){
    console.log('click2',this) // click2  undefined
  }
  handleClick(){
    console.log('click2',this.a) // click2  100  绑定 App 的实例
  }
  
  handleClick3=()=>{
    console.log('click3',this.a) // click3  100 箭头函数箭头函数`的this指向指向上下文，所以永久能拿到当前组件实例的this指向
  }
  handleClick3evt=(evt)=>{
    console.log('handleClick3evt',evt,evt.target) // click3  SyntheticBaseEvent  <button>SyntheticBaseEvent</button>
  }
  handleClick4=()=>{
    console.log('click4',this.a) // click4 100 箭头函数，还可以传参
  }
}
/**
 * React 并不会真正的绑定到每一个具体 <> 的元素上，而是采用事件代理的模式:
*/

  // this 的指向 复习
  var obj1 ={
    name:'obj1',
    getName(){
      console.log('obj1')
    }
  }
  var obj2 ={
    name:'obj1',
    getName(){
      console.log('obj1')
    }
  }
  obj1.getName() // obj1
  obj2.getName() // obj2
  obj1.getName.call(obj2) // obj2
  obj1.getName.apply(obj2) // obj2
  obj1.getName.bind(obj2) // 没有打印内容
  obj1.getName.bind(obj2)()  // 自动执行 obj2


```
## Ref 应用
./src/index.js
```js
import React from 'react';
import ReactDOM from 'react-dom';
import App from './01-base/07-ref.js'
ReactDOM.render(
  // 严格模式
  <React.StrictMode>
    <App />
  </React.StrictMode>,
    // <App />,
    document.getElementById('root')
)

```
### 以前的写法
./src/01-base/07-ref.js
```js
import React, { Component } from 'react'
export default class App extends Component {
  render() {
    return (
      <div>
        Ref的应用
        <input ref="mytext"></input>
        <button onClick={()=>{
          // 获取Dom/组件 this.refs.xxx 即将被弃用 严格模式下会报错
          console.log('click',this.refs.mytext,this.refs.mytext.value) // click <input /> 输入的内容
        }}></button>
      </div>
    )
  }
}

```
### 现在的写法
```js
import React, { Component } from 'react'
export default class App extends Component {
  myref= React.createRef() // 返回一个ref对象
  render() {
    return (
      <div>
        Ref的应用
        <input ref={this.myref}></input>
        <button onClick={()=>{
          // 使用 React.createRef()
          console.log("click",this.myref,this.myref.value) // this.myref----{current:input,[[Proptotype]]: Object} 
        }}>点击</button>
        <button onClick={this.handleClick}></button>
        <button onClick={this.handleClick2.bind(this)}></button>
        <button onClick={this.handleClick3}></button>
      </div>
    )
  }
  handleClick(){
    // 这里的 this指向 div 不是 App
    console.log("handleClick ",this.myref,this.myref.value) // undefined
  }
  handleClick2(){
    // 这里的 this指向 App
    console.log("handleClick2 ",this.myref,this.myref.value) // this.myref----{current:input,[[Proptotype]]: Object} 
  }
  handleClick3=()=>{
    // 这里的 this指向 App
    console.log("handleClick3 ",this.myref,this.myref.value) // this.myref----{current:input,[[Proptotype]]: Object} 
  }
}

```

# 组件的数据挂载方式
## state状态
./src/01-base/08-state.js
```js
import React, { Component } from 'react'

export default class App extends Component {
  // state={
  //   mytext:"收藏",
  //   myShow:true
  // }
  // 还可以这样定义state
  constructor(){
    super()
    this.state={
      mytext:"收藏",
      myShow:true,
      myname:'Iekika'
    }
  }
  render() {
    return (
      <div>
        App
        <button onClick={()=>{
          // this.state.mytext = "取消" // 不可以直接修改 state状态
          // 需要这样修改 间接修改
          this.setState({
            mytext:"取消收藏",
            // setState 可以合并修改的状态
            myname:'kkkkk'
          })
        }}>{this.state.mytext}</button>
        {/* 项目中更推荐这种写法 */}
        <button onClick={()=>{
          this.setState({
            myShow:!this.state.myShow
          })
          // 需要对接接口时
          if(this.state.myShow){
            console.log('收藏的逻辑')
          }else{
            console.log("取消收藏的逻辑")
          }
        }}>{this.state.mytext ? "收藏": "取消收藏"}</button>
      </div>
    )
  }
}

```
## 渲染数据
./src/01-base/09-render.js
```js
import React, { Component } from 'react'

export default class App extends Component {
  state={
    // list:["1111","2222","3333"]
    listdata:{
      {id:1,text:"1111"},
      {id:2,text:"2222"},
      {id:3,text:"3333"}
    }
  }
  render() {
    // const newlist = this.state.list.map(item=><li>{item}</li>)
    // 确保节点有一个唯一的标识key，列表的复用和重排，事件的错误绑定，设置key，提高性能
     const newlist = this.state.list.map(item=><li key={item.id}>{item.text}</li>)
    return (
      <div>
        App渲染列表
        <ul>
          {/* 
          这种写法是错误的
          {
            this.state.list.map(item=>
              <li>{item}</li>
              )
          } */}
          {newlist}
          
        </ul>
      </div>
    )
  }
}

```

## todolist 案例
./src/10-todolist.js
```js
import React, { Component } from 'react'
import './css/04.css'
export default class App extends Component {
  constructor(){
    super()
      this.state = {
      listdata:[
        {id:1,text:"1111"},
        {id:2,text:"2222"},
        {id:3,text:"3333"}
      ] 
      }
  }
  myref= React.createRef() // 返回一个ref对象
  render() {
    // const list = this.state.listdata.map(item=><li key={item.id}>{item.text}</li>)
    return (
      <div>
        TodoList案例
        <hr></hr>
        <input ref={this.myref}></input>
        <button onClick={this.handleClick}>add</button> 
        {/* <ul> {list}</ul> */}
        <ul>
          {
            this.state.listdata.map((item,index)=>
              <li key={item.id}>
                {/*item.text*/}
                {/*富文本展示 dangerouslySetInnerHTML={{__html:xxxx}}*/} 
                <span dangerouslySetInnerHTML={{__html:item.text}}></span>
                {/* <button onClick={this.handleDelClick.bind(this,index)}>del</button> */}
                <button onClick={()=>this.handleDelClick(index)}>del</button>
              </li>
              )
          }
        </ul>
        {/* {this.state.listdata.length===0?<div>暂无数据</div>:null}  */}
        {/* {this.state.listdata.length===0&&<div>暂无数据</div>}  */}
        <div className={this.state.listdata.length===0?'':'hidden'}>暂无数据</div>
      </div>
    )
  }
  handleClick=()=>{
    console.log("click",this.myref.current.value)
    // 不要直接修改 this.state的状态
    // this.state.datalist.push(this.myref.current.value)
    // this.setState({
    //   listdata:this.state.datalist
    // })
    // 我们应该这样写：
    const newlist = [...this.state.listdata] // 深拷贝一份数据
    // newlist.push(this.myref.current.value)
    newlist.push({
      id:Math.random()*100000000,
      text:this.myref.current.value
    })
    this.setState({
      listdata:newlist
    })
    console.log("listdata",this.state.listdata)
    // 清空输入框
    this.myref.current.value = ""
  }
  handleDelClick(index){
    console.log('del')
    // 不要直接修改状态，会造成不可预期的后果
    const list = this.state.listdata.concat()
    list.splice(index,1)
    this.setState({
      listdata:list
    })

  }
}

```
## 卖座网案例 
### 卖座网底部导航active案例
./src/01-base/11-Action.js
```js
import React, { Component } from 'react'
import './css/11.css'
import Film from './maizuocomponent/Film'
import Cinema from './maizuocomponent/Cinema'
import Center from './maizuocomponent/Center'

export default class App extends Component {
  state={
    list:[
      {
        id:1,
        text:"电影",
      },
      {
        id:2,
        text:"影院"
      },
      {
        id:3,
        text:"我的"
      }
    ],
    current:0
  }
  which(){
    switch(this.state.current){
      case 0:
        return <Film></Film>
      case 1:
        return <Cinema></Cinema>
      case 2:
        return <Center></Center>
      default:
        return null
    }
  }
  render() {
    return (
      <div>
        {/* 显示内容 */}
        {/* 
          {
              this.state.current===0 && <Film></Film>
          }
          {
              this.state.current===1 && <Cinema></Cinema>
          }
          {
              this.state.current===2 && <Center></Center>
          } 
        */}
        {
          // 我们可以使用表达式-支持函数表达式
          this.which()
        }
        <ul>
        {
          this.state.list.map((item,index)=>
          <li key={item.id} className={this.state.current===index?'active':''} onClick={()=>this.handleClick(index)}>{item.text}</li>
          )
        }          
        </ul>
      </div>
    )
  }
  handleClick(index){
    this.setState({current:index})
  }
}

```

### 卖座网列表&&input输入过滤
./src/maizuocomponent/cinema.jsx
```js
import React, { Component } from 'react'
import axios from 'axios'
export default class Cinema extends Component {
  constructor(){
    super()
    this.state={
      cinemaList:[],
      backcinemaList:[]
    }

    // 1. 生命周期里请求数据--后面了解
    // 2.axios 第三方库 ，专门用于数据请求
    // axios.get("https://m.maizuo.com/gateway?cityId=440100&ticketFlag=1&k=6427887").then(res=>{
    //   console.log(res)
    // }).catch(err=>{
    //   console.log(err)
    // })

    axios({
      url:"https://m.maizuo.com/gateway?cityId=440100&ticketFlag=1&k=4475775",
      method:"get",
      headers:{
        'X-Client-Info': '{"a":"3000","ch":"1002","v":"5.2.0","e":"16556881321698500651778049","bc":"440100"}',
        'X-Host': 'mall.film-ticket.cinema.list'
      }
    }).then(res=>{
      // 有两条数据主要是开了严格模式
      console.log(res.data)
      this.setState({
        // 关掉严格模式
        cinemaList:res.data.data.cinemas,
        backcinemaList:res.data.data.cinemas
      })
    })
  
  }
  render() {
    return (
      <div>
        {/* Cinema列表 */}
        <input onInput={this.handleInput}></input>
          {
            this.state.cinemaList.map(item=>
            <dl key={item.cinemaId}>
              <dt>{item.name}</dt>
              <dd>{item.address}</dd>
            </dl>
              )
            }

      </div>
    )
  }
  handleInput=(evt)=>{
    console.log('input',evt.target.value)
    const newlist = this.state.backcinemaList.filter(item=>item.name.toUpperCase().includes(evt.target.value.toUpperCase()) || item.address.toUpperCase().includes(evt.target.value))
    console.log(newlist)
    // cinemaList 每次都会被覆盖 所以需要哪一个备份数据操作
    this.setState({
      cinemaList:newlist
    })

  }
}
/**
 * filter
 */
// var arr =["aaa","abc","bcc"]
// var newArr = arr.filter(item=>item.includes("a"))
// console.log(newArr)
```
![](https://i0.hdslb.com/bfs/album/a079e6d5bae5d0dc6d2d1f84df325871f9e99c2c.png)
![](https://i0.hdslb.com/bfs/album/203b47213f0a2ce4f3f13c4f0c918188890a7258.png)

## setState 异步
./src/12-setState-Syncawait.js
```js
import React, { Component } from 'react'

export default class Syncawait extends Component {
  state={
    count:0
  }
  render() {
    return (
      <div>
        {this.state.count}
        <button onClick={this.handleAdd1}>add1</button>
        <button onClick={this.handleAdd2}>ad2</button>
      </div>
    )
  }
  handleAdd1=()=>{
    // 1.
    // this.setState({
    //   count:this.state.count + 1
    // })
    //   count:this.state.count + 1
    // this.setState({
    //   count:this.state.count+1
    // })
    //  count:this.state.count + 1
    // this.setState({
    //   count:this.state.count+1
    // })
    //   count:this.state.count + 1

    // 3.
    this.setState({
      count:this.state.count + 1
    },()=>{
      console.log(this.state.count)
    })
    this.setState({
      count:this.state.count+1
    },()=>{
      console.log(this.state.count)
    })
    this.setState({
      count:this.state.count+1
    },()=>{
      console.log(this.state.count)
      // 状态和真实dom已经更新完了
    })
  }
  handleAdd2=()=>{
    // 2
    setTimeout(()=>{
      this.setState({
        count:this.state.count + 1
      })
      this.setState({
        count:this.state.count+1
      })
      this.setState({
        count:this.state.count+1
      })
    })
  }
}
/**
 * setState 会合并状态
 * 1.setState 处在同步的逻辑中，异步更新状态，更新真实dom
 * 2.setState 处在异步的逻辑中，同步更新状态，更新真实dom
 * 
 * 3.setState 接收第二个参数，第二个参数是回调函数，状态和dm更新完后就会触发
 */

```
## 属性(props)
### 介绍
props 是正常是外部传入的，组件内部也可以通过一些方式来初始化的设置，属性不能被组件自己更
改，但是你可以通过父组件主动重新渲染的方式来传入新的 props

属性是描述性质、特点的，组件自己不能随意更改。

之前的组件代码里面有 props 的简单使用，总的来说，在使用一个组件的时候，可以把参数放在标签的
属性当中，所有的属性都会作为组件 props 对象的键值。通过箭头函数创建的组件，需要通过函数的
参数来接收 props : 

(1) 在组件上通过key=value 写属性,通过this.props获取属性,这样组件的可复用性提高了。 

(2) 注意在传参数时候，如果写成isShow="true" 那么这是一个字符串 如果写成isShow={true} 这个 是布尔值 

(3) {...对象} 展开赋值 

(4) 默认属性值
./src/15-props.js
```js
import React, { Component } from 'react'
import Navbar from './src/Navbar'
export default class props extends Component {
  render() {
    return (
      <div>
        <div>
          <h2>首页</h2>
          {/* 
          leftShow 传入 props的是一个字符串
          <Navbar title="首页" leftShow="false"></Navbar> 
          */}
          <Navbar title="首页" leftShow={false}></Navbar>
        </div>
        <div>
          <h2>列表</h2>
          <Navbar title="列表"></Navbar>
        </div>
        <div>
          <h2>购物车</h2>
          <Navbar title="购物车"></Navbar>
        </div>
        
      </div>
    )
  }
}


```
### 类/函数 组件Props
./src/16.propsFun.js
```js
import React, { Component } from 'react'
import Navbar from './src/Navbar'
import Sidebar from './src/Sidebar'
export default class propsFun extends Component {
  render() {
    return (
      <div>
        <div>
          {/* 类组件 */}
          <Navbar title="购物车"></Navbar>
          {/* 函数组件 */}
          <Sidebar bg="green" position="left"></Sidebar>
        </div>
      </div>
    )
  }
}


```
./src/Navbar/index.js
```js
// 函数式组件 rfc
import React from 'react'

export default function Sidebar(props) {
  // console.log(this)
  let { bg,position} = props
  var obj1 = {
    left:0
  }
  var obj2={
    right:0
  }
  var obj={
    background:bg,
    width:'200px',
    position:'fixed'
  }
  // 可以利用合并
  var styleobj = position === 'left' ? {...obj,...obj1} : {...obj,...obj2} 
  return (
    // <div style={{background:bg,width:'200px',position:position}}>
    <div style={styleobj}>
      <ul>
        <li>11111</li>
        <li>11111</li>
        <li>11111</li>
        <li>11111</li>
        <li>11111</li>
        <li>11111</li>
        <li>11111</li>
        <li>11111</li>
      </ul>
    </div>
  )
}


```
### 属性 VS state
相似点：都是纯js对象，都会触发render更新，都具有确定性（状态/属性相同，结果相同）
不同点：

1. 属性能从父组件获取，状态不能

2. 属性可以由父组件修改，状态不能

3. 属性能在内部设置默认值，状态也可以，设置方式不一样

4. 属性不在组件内部修改，状态要在组件内部修改

5. 属性能设置子组件初始值，状态不可以

6. 属性可以修改子组件的值，状态不可以

state 的主要作用是用于组件保存、控制、修改自己的可变状态。 
state 在组件内部初始化，可以被组件自身修改，而外部不能访问也不能修改。你可以认为 state 是一个局部的、只能被组件自身控制的数据源。 state 中状态可以通过 this.setState 方法进行更新， setState 会导致组件的重新渲染。

props 的主要作用是让使用该组件的父组件可以传入参数来配置该组件。它是外部传进来的配置参数，组件内部无法控制也无法修改。除非外部组件主动传入新的 props ，否则组件的 props 永远保持不变。

没有 state 的组件叫无状态组件（stateless component），设置了 state 的叫做有状态组件（stateful component）。因为状态会带来管理的复杂性，我们尽量多地写无状态组件，尽量少地写有状态的组件。这样会降低代码维护的难度，也会在一定程度上增强组件的可复用性。

```js
import React, { Component } from 'react'

class Child extends Component{
    render(){
        return <div>
            child-{this.props.text}

            <button onClick={()=>{
                this.props.text = "333333333333333333"
            }}>click-子</button>
        </div>
    }
}

export default class App extends Component {
    state = {
        text:"111111111"
    }
    render() {
        return (
            <div>
                <button onClick={()=>{
                    this.setState({
                        text:"2222222"
                    })
                }}>click-父</button>
                <Child text = {this.state.text}/>
            </div>
        )
    }
}



```

# 表单中的受控组件与非受控组件
## 1.非受控组件
React 要编写一个非受控组件，可以使用ref来从DOM节点中获取表单数据,就是非受控组件。
例如，下面的代码使用非受控组件接受一个表单的值：
```js
class NameForm extends React.Component { 
  constructor(props) { 
    super(props); this.handleSubmit = this.handleSubmit.bind(this); 
    this.input = React.createRef(); 
  }
handleSubmit(event) { 
  alert('A name was submitted: ' + this.input.current.value); 
  event.preventDefault(); }
  render() { 
    return ( 
      <form onSubmit={this.handleSubmit}> 
        <label> Name: 
          <input type="text" ref={this.input} /> 
        </label> 
        <input type="submit" value="Submit" /> 
      </form> ); 
    } 
    }

```
因为非受控组件将真实数据储存在 DOM 节点中，所以在使用非受控组件时，有时候反而更容易同时集
成 React 和非 React 代码。如果你不介意代码美观性，并且希望快速编写代码，使用非受控组件往往可
以减少你的代码量。否则，你应该使用受控组件。
**默认值**
在 React 渲染生命周期时，表单元素上的 value 将会覆盖 DOM 节点中的值，在非受控组件中，你经
常希望 React 能赋予组件一个初始值，但是不去控制后续的更新。 在这种情况下, 你可以指定一个
defaultValue 属性，而不是 value 。
```js
render() {
  return (
    <form onSubmit={this.handleSubmit}> 
    <label> Name: 
      <input defaultValue="Bob" type="text" ref={this.input} /> 
    </label> 
    <input type="submit" value="Submit" /> 
    </form> 
  ); 
  }

```
同样， <input type="checkbox"> 和 <input type="radio"> 支持 defaultChecked ， <select> 和 <textarea> 支持 defaultValue 。
## 受控组件
```js
class NameForm extends React.Component {  
  constructor(props) {    
    super(props);    
    this.state= {value: ''};
    this.handleChange=this.handleChange.bind(this);    
    this.handleSubmit=this.handleSubmit.bind(this);  
  }
  handleChange(event) {    
    this.setState({value: event.target.value});  
  }
  handleSubmit(event) {    
    alert('提交的名字: '+this.state.value);    
    event.preventDefault();  
  }
  render() {    
    return (      
      <form onSubmit={this.handleSubmit}>        
      <label> 名字:      
         <input type="text"value={this.state.value} onChange={this.handleChange} />
      </label>  
       <input type="submit"value="提交"/> 
       </form>
          ); 
  }
}
```
由于在表单元素上设置了`value`属性，因此显示的值将始终为`this.state.value`,这使得React的state成为唯一的数据源。由于`handelchange`在每次按键是都会执行并更新React的state，因此显示的值将随着用户输入而更新。
对于受控组件来说，输入的值始终由React的state驱动，你也可以将value传递给其他UI元素，或者其他事件处理函数重置，但这意味着你需要编写更多的代码。

> 注意：另一种说法(广义范围的说法),React组件的数据渲染是否被调用者传递的props完全控制，控制则为受控组件，否则非受控组件。




# 组件的通信方式
## 父子组件通信方式
(1)传递数据(父传子)与传递方法(子传父)
(2)ref标记(父组件拿到子组件的引用，从而调用子组件的方法)
  在父组件中清除子组件的input输入框的value值。this.refs.from.reset()
## 非父子组件的通信方式
(1)状态提升(中间人模式)
   React中的状态提升概括来说，就是多个组件需要共享的状态提升到它们最近的父组件上，在父组件上改变这个状态然后通过props分发给子组件。
(2)发布订阅模式实现
(3)context状态数传参
   ```js
  //  a.先定义全局context对象
  import React from 'react'
  const GlobalContext = React.createContext()
  export default GlobalContext
   ```
   ```js
  //  b.根组件引入GlobalContext，并使用GlobalContText.Provider(生产者)
  // 重新包装根组件 class App()
  <GlobalContext.Provider
  value={{
    name:'Iekika',
    age:18,
    content:this.state.content,
    show:this.show.bind(this),
    hide:this.hide.bind(this)
  }}
  >
  </GlobalContext.Provider>

   ```
   ```js
  //  c.任意组件引入 GlobalContext 并调用context,使用GlobalConntext.Consumer(消费者)
  <GlobalContext>
  {
    context=>{
      this.myshow = = context.show // 可以在当前组件任意函数触发
      this.myhide = context.hide; // 可以在当前组件任意函数触发 
      return (
        <div>
        {context.name}-{context.age}-{context.context}
        </div>
      )
    }
  }
  </GlobalContext>

   ```
   注意： GlobalContext.Consumer 内必须是回调函数，通过context方法改变根组件状态
> context 优缺点:
> 优点:跨组件访问数组
> 缺点: react组件树种某个上级组件shouldComponentUpdate返回false，当context更新时，不会引起下级组件的更新。
