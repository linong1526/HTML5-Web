# 创建一个react项目
1.进行局部安装
```ssh
 npx create-react-app my-app-bli
 cd my-app-bli
 npm start
```
生成目录：
├──README.md             使用方法的文档
├──node_modules          所有的依赖安装的目录
├──package-lock.json     锁定安装时的包的版本号,保证团队的依赖能保证一致。
├──package.json         
├──public                静态公共目录
└──src                   开发用的源代码目录

出现如下信息，表示安装成功:
```ssh 
PS F:\学习更多\githubLearn\HTML5-Web\react\practices> npx create-react-app my-app-bli
Need to install the following packages:
  create-react-app
Ok to proceed? (y)
npm WARN deprecated tar@2.2.2: This version of tar is no longer supported, and will not receive security updates. Please upgrade asap.

Creating a new React app in F:\学习更多\githubLearn\HTML5-Web\react\practices\my-app-bli.

Installing packages. This might take a couple of minutes.
Installing react, react-dom, and react-scripts with cra-template...


added 1393 packages in 3m

Installing template dependencies using npm...
npm WARN deprecated source-map-resolve@0.6.0: See https://github.com/lydell/source-map-resolve#deprecated

added 52 packages in 10s
Removing template package using npm...


removed 1 package in 4s

Success! Created my-app-bli at F:\学习更多\githubLearn\HTML5-Web\react\practices\my-app-bli
Inside that directory, you can run several commands:

  npm start
    Starts the development server.

  npm run build
    Bundles the app into static files for production.

  npm test
    Starts the test runner.

  npm run eject
    Removes this tool and copies build dependencies, configuration files
    and scripts into the app directory. If you do this, you can’t go back!

We suggest that you begin by typing:

  cd my-app-bli
  npm start

Happy hacking!

```
2. 删除`src`下的文件，重新新建一个`index.js`文件

```js 
// 从 react 的包当中引入了 React。只要你要写 React.js 组件就必须引入React, 因为react里有 一种语法叫JSX，稍后会讲到JSX，要写JSX，就必须引入
React import React from 'react' 
// ReactDOM 可以帮助我们把 React 组件渲染到页面上去，没有其它的作用了。它是从 react-dom 中 引入的，而不是从 react 引入。 
import ReactDOM from 'react-dom' 
// ReactDOM里有一个render方法，功能就是把组件渲染并且构造 DOM 树，然后插入到页面上某个特定的 元素上 
ReactDOM.render( 
  // 这里就比较奇怪了，它并不是一个字符串，看起来像是纯 HTML 代码写在 JavaScript 代码里面。语 法错误吗？这并不是合法的 JavaScript 代码, “在 JavaScript 写的标签的”语法叫 JSX- JavaScript XML。
   <h1>欢迎进入React的世界</h1>, 
   // 渲染到哪里 
   document.getElementById('root') 
)

```
# JSX语法和组件
## 体验JSX语法
```js
import React from 'react';
import ReactDOM from 'react-dom';

//写法一：
ReactDOM.render(
  <div>
    <h1>1111</h1>
    <ul>
      <li>111</li>
      <li>111</li>
      <li>111</li>
    </ul>
  </div>,
  document.getElementById('root')
)
// 写法二:与写法一等效
ReactDOM.render(
React.createElement('div',{id:'app',className:'bbb'},'内容'),
  document.getElementById('root')
)

```
## class组件
* ES6写法
  ./scr/inde.js
  ```js
  import React from 'react';
  import ReactDOM from 'react-dom';
  import './01-base/01-class' // 引入自动加载 

  ReactDOM.render(
      React.createElement('div',{id:'app',className:'bbb'},'内容'),
      document.getElementById('root')
  )

  ```
  ./src/0-base/01-class
  ```js
  // ES6写法
  class Test{
    constructor(){
      this.a = 1
    }
    testa(){
      console.log("testa")
    } 
  }
  class ChildTest extends Test{
    testb(){
      console.log("testb")
    }
  }
  // var obj = new Test()
  // obj.testa() // 执行方法 输出testa
  // console.log(obj.a) // 打印属性  1

  var obj = new ChildTest()
  obj.testa() // 执行方法 输出 testa
  console.log(obj.a) // 输出 1

  ```
* ES7 写法
./src/index.js
```js 
import React from 'react';
import ReactDOM from 'react-dom';
import App from './01-base/01-class'
ReactDOM.render(
    <App />,
    document.getElementById('root')
)

```
  ./src/0-base/01-class
```js
// ES7 
// import React from 'react';
// class App extends React.Component{
//   render(){
//     return (
//       <div>1111</div>
//     )
//   }
// } 

import React, { Component } from 'react'
class App extends Component{
render(){
  // renturn () 用括号括起来，表示式回车下的属于一部分的内容
  return (
      <div>
        <h1>1111</h1>
        <ul>
          <li>111</li>
          <li>111</li>
          <li>111</li>
        </ul>
      </div>
  )
}
} 
export default App

```
* 复用组件(推荐)
组件 必须大写开头，否则会报错
为了让代码编写更规范，我们可以下载 插件 `ES7+ React/Redux/React-Native/JS snippets`
./src/index.js
```js
import React from 'react';
import ReactDOM from 'react-dom';
import App from './01-base/01-class'
ReactDOM.render(
    <App />,
    document.getElementById('root')
)
```
  ./src/0-base/01-class
  ```js 
import React, { Component } from 'react'
export default class App extends Component {
  render() {
    return (
      <div>01-class</div>
    )
  }
}

  ```
## 函数组件
16.8之前  无状态组件
16.8   react hooks 
./src/index/j
```js
import React from 'react';
import ReactDOM from 'react-dom';
import App from './01-base/02-fun'
ReactDOM.render(
    <App />,
    document.getElementById('root')
)
```
./src/01-base/02-fun.js
```js
function App(){
  return (
    <div>function Component</div>
  )
}

export default App

```
## 组件嵌套
./src/index.js
```js
import React from 'react';
import ReactDOM from 'react-dom';
import App from './01-base/03-Nesting.js'
ReactDOM.render(
    <App />,
    document.getElementById('root')
)
```
./src/01-base/03-Nesting.js
```js
import React, { Component } from 'react'
class Child extends Component{
  render(){
    return (
      <div>Child Component</div>
    )
  }
}
class Navbar extends Component {
  render(){
    return (
    <div>
      Navbar
      <Child></Child>
    </div>
    )
  }
}
function Swiper(){
  return <div>Swiper</div>
}
// const Tabbar =()=><div>Tabbar</div>
const Tabbar =()=>{
  return <div>Tabbar</div>
}

export default class App extends Component {
  render() {
    return (
      <div>
        {/* 想要在 Navbar 里嵌套子组件， 需要 在Navbar组件放入一个子组件Child，在子组件里写内容 ，而不是在放在<Navbar>标签中*/}
        <Navbar></Navbar>
        <Swiper></Swiper>
        <Tabbar></Tabbar>
      </div>
    )
  }
}

```
## 组件样式
./src/index.js
```js
import React from 'react';
import ReactDOM from 'react-dom';
import './01-base/css/04.css' // y引入外部css样式
import App from './01-base/04-style.js'
ReactDOM.render(
    <App />,
    document.getElementById('root')
)

```
./src/01-base/04-style.js
```js
import React, { Component } from 'react'

export default class App extends Component {
  render() {
    var myname = 'Iekaki'
    // 此样式写仅为演示，项目中不推荐这样使用
    var obj ={
      background:'red', // 需要加入引号
      backgroundColor:'green', // 单一属性需要 写成驼峰写法
      fontSize:'10px'
    }
    return (
      <div>
        {/* 模板语法 */}
        {10+20}
        {/* 变量 */}
        {10+20}- {myname}
        {/* 三目运算 ，加减乘除 ，字符串*/}
        {10>20?'aaa':'bbb'}
        {/* style={} 需要放入一个对象 */}
        <div style={{background:"red"}}>111111</div>
        <div style={obj}>111111</div>
        {/* 属性需要驼峰写法 css样式 需要引入外部css文件*/}
        {/* 另外 class ,for是react的关键字 不可以使用 
        <div class='active'>111111</div>
        <label for='username'>用户名:</label>
        */}
        <div className='active'>111111</div>
        <div id='active'>111111</div>
        <label htmlFor=''>用户名:</label>
        <label htmlFor='username'>用户名:</label>
          <input type="text" id='username'></input>
        
      </div>
    )
  }
}
```
## 事件对象
###  使用
./src/index.js
```js
import React from 'react';
import ReactDOM from 'react-dom';
import App from './01-base/05-event.js'
ReactDOM.render(
    <App />,
    document.getElementById('root')
)

```
./src/01-base/05-event.js
```js
import React, { Component } from 'react'

export default class App extends Component {
  render() {
    return (
      <div>
        05-event
        <input />
        {/* on + 事件类型（注意要写驼峰） */}
        <button onMouseEnter={()=>{
          console.log('onMouseEnter')
        }}>onMouseEnter</button>
        <button onMouseOver={()=>{
          console.log('onMouseEnter')
        }}>onMouseOver</button>

        {/* 无过多逻辑 推荐用法 */}
        <button onClick={()=>{
          console.log('click1')
        }}>add1</button>

        {/* 可以定义在外边  不要加() 画蛇添足 <button onClick={this.handleClick()}></button>*/}
        <button onClick={this.handleClick2}>dd2</button>
        <button onClick={this.handleClick3}>add3</button> 
        {/*组合  逻辑过多 推荐写法*/}
        <button onClick={()=>{
          this.handleClick4()
        }}>add4</button>     
        </div>
    )
  }
  handleClick2(){
    console.log('click2')
  }
  handleClick3=()=>{
    console.log('click3')
  }
  handleClick4=()=>{
    console.log('click3')
  }
}


```
### 事件绑定
./src/01-base/06-eventbind.js
```js
import React, { Component } from 'react'
export default class App extends Component {
  a = 1000
  render() {
    return (
      <div>
        05-event
        <input />
        {/* on + 事件类型（注意要写驼峰） */}
        <button onClick={()=>{
          console.log('click1',this.a)
        }}>add1</button>
        <button onClick={this.handleClick2}>add3</button> 
        <button onClick={this.handleClick.bind(this)}>add-bind不推荐这种写法</button> 
        <button onClick={this.handleClick3}>add3</button> 
        <button onClick={this.handleClick3evt}>SyntheticBaseEvent</button> 
        <button onClick={()=>{
          this.handleClick4()
        }}>add4</button>     
        </div>
    )
  } 
  handleClick2(){
    console.log('click2',this) // click2  undefined
  }
  handleClick(){
    console.log('click2',this.a) // click2  100  绑定 App 的实例
  }
  
  handleClick3=()=>{
    console.log('click3',this.a) // click3  100 箭头函数箭头函数`的this指向指向上下文，所以永久能拿到当前组件实例的this指向
  }
  handleClick3evt=(evt)=>{
    console.log('handleClick3evt',evt,evt.target) // click3  SyntheticBaseEvent  <button>SyntheticBaseEvent</button>
  }
  handleClick4=()=>{
    console.log('click4',this.a) // click4 100 箭头函数，还可以传参
  }
}
/**
 * React 并不会真正的绑定到每一个具体 <> 的元素上，而是采用事件代理的模式:
*/

  // this 的指向 复习
  var obj1 ={
    name:'obj1',
    getName(){
      console.log('obj1')
    }
  }
  var obj2 ={
    name:'obj1',
    getName(){
      console.log('obj1')
    }
  }
  obj1.getName() // obj1
  obj2.getName() // obj2
  obj1.getName.call(obj2) // obj2
  obj1.getName.apply(obj2) // obj2
  obj1.getName.bind(obj2) // 没有打印内容
  obj1.getName.bind(obj2)()  // 自动执行 obj2


```
## Ref 应用
./src/index.js
```js
import React from 'react';
import ReactDOM from 'react-dom';
import App from './01-base/07-ref.js'
ReactDOM.render(
  // 严格模式
  <React.StrictMode>
    <App />
  </React.StrictMode>,
    // <App />,
    document.getElementById('root')
)

```
### 以前的写法
./src/01-base/07-ref.js
```js
import React, { Component } from 'react'
export default class App extends Component {
  render() {
    return (
      <div>
        Ref的应用
        <input ref="mytext"></input>
        <button onClick={()=>{
          // 获取Dom/组件 this.refs.xxx 即将被弃用 严格模式下会报错
          console.log('click',this.refs.mytext,this.refs.mytext.value) // click <input /> 输入的内容
        }}></button>
      </div>
    )
  }
}

```
### 现在的写法
```js
import React, { Component } from 'react'
export default class App extends Component {
  myref= React.createRef() // 返回一个ref对象
  render() {
    return (
      <div>
        Ref的应用
        <input ref={this.myref}></input>
        <button onClick={()=>{
          // 使用 React.createRef()
          console.log("click",this.myref,this.myref.value) // this.myref----{current:input,[[Proptotype]]: Object} 
        }}>点击</button>
        <button onClick={this.handleClick}></button>
        <button onClick={this.handleClick2.bind(this)}></button>
        <button onClick={this.handleClick3}></button>
      </div>
    )
  }
  handleClick(){
    // 这里的 this指向 div 不是 App
    console.log("handleClick ",this.myref,this.myref.value) // undefined
  }
  handleClick2(){
    // 这里的 this指向 App
    console.log("handleClick2 ",this.myref,this.myref.value) // this.myref----{current:input,[[Proptotype]]: Object} 
  }
  handleClick3=()=>{
    // 这里的 this指向 App
    console.log("handleClick3 ",this.myref,this.myref.value) // this.myref----{current:input,[[Proptotype]]: Object} 
  }
}

```

# 组件的数据挂载方式
## state状态
./src/01-base/08-state.js
```js
import React, { Component } from 'react'

export default class App extends Component {
  // state={
  //   mytext:"收藏",
  //   myShow:true
  // }
  // 还可以这样定义state
  constructor(){
    super()
    this.state={
      mytext:"收藏",
      myShow:true,
      myname:'Iekika'
    }
  }
  render() {
    return (
      <div>
        App
        <button onClick={()=>{
          // this.state.mytext = "取消" // 不可以直接修改 state状态
          // 需要这样修改 间接修改
          this.setState({
            mytext:"取消收藏",
            // setState 可以合并修改的状态
            myname:'kkkkk'
          })
        }}>{this.state.mytext}</button>
        {/* 项目中更推荐这种写法 */}
        <button onClick={()=>{
          this.setState({
            myShow:!this.state.myShow
          })
          // 需要对接接口时
          if(this.state.myShow){
            console.log('收藏的逻辑')
          }else{
            console.log("取消收藏的逻辑")
          }
        }}>{this.state.mytext ? "收藏": "取消收藏"}</button>
      </div>
    )
  }
}

```
## 渲染数据
./src/01-base/09-render.js
```js
# 创建一个react项目
1.进行局部安装
```ssh
 npx create-react-app my-app-bli
 cd my-app-bli
 npm start
```
生成目录：
├──README.md             使用方法的文档
├──node_modules          所有的依赖安装的目录
├──package-lock.json     锁定安装时的包的版本号,保证团队的依赖能保证一致。
├──package.json         
├──public                静态公共目录
└──src                   开发用的源代码目录

出现如下信息，表示安装成功:
```ssh 
PS F:\学习更多\githubLearn\HTML5-Web\react\practices> npx create-react-app my-app-bli
Need to install the following packages:
  create-react-app
Ok to proceed? (y)
npm WARN deprecated tar@2.2.2: This version of tar is no longer supported, and will not receive security updates. Please upgrade asap.

Creating a new React app in F:\学习更多\githubLearn\HTML5-Web\react\practices\my-app-bli.

Installing packages. This might take a couple of minutes.
Installing react, react-dom, and react-scripts with cra-template...


added 1393 packages in 3m

Installing template dependencies using npm...
npm WARN deprecated source-map-resolve@0.6.0: See https://github.com/lydell/source-map-resolve#deprecated

added 52 packages in 10s
Removing template package using npm...


removed 1 package in 4s

Success! Created my-app-bli at F:\学习更多\githubLearn\HTML5-Web\react\practices\my-app-bli
Inside that directory, you can run several commands:

  npm start
    Starts the development server.

  npm run build
    Bundles the app into static files for production.

  npm test
    Starts the test runner.

  npm run eject
    Removes this tool and copies build dependencies, configuration files
    and scripts into the app directory. If you do this, you can’t go back!

We suggest that you begin by typing:

  cd my-app-bli
  npm start

Happy hacking!

```
2. 删除`src`下的文件，重新新建一个`index.js`文件

```js 
// 从 react 的包当中引入了 React。只要你要写 React.js 组件就必须引入React, 因为react里有 一种语法叫JSX，稍后会讲到JSX，要写JSX，就必须引入
React import React from 'react' 
// ReactDOM 可以帮助我们把 React 组件渲染到页面上去，没有其它的作用了。它是从 react-dom 中 引入的，而不是从 react 引入。 
import ReactDOM from 'react-dom' 
// ReactDOM里有一个render方法，功能就是把组件渲染并且构造 DOM 树，然后插入到页面上某个特定的 元素上 
ReactDOM.render( 
  // 这里就比较奇怪了，它并不是一个字符串，看起来像是纯 HTML 代码写在 JavaScript 代码里面。语 法错误吗？这并不是合法的 JavaScript 代码, “在 JavaScript 写的标签的”语法叫 JSX- JavaScript XML。
   <h1>欢迎进入React的世界</h1>, 
   // 渲染到哪里 
   document.getElementById('root') 
)

```
# JSX语法和组件
## 体验JSX语法
```js
import React from 'react';
import ReactDOM from 'react-dom';

//写法一：
ReactDOM.render(
  <div>
    <h1>1111</h1>
    <ul>
      <li>111</li>
      <li>111</li>
      <li>111</li>
    </ul>
  </div>,
  document.getElementById('root')
)
// 写法二:与写法一等效
ReactDOM.render(
React.createElement('div',{id:'app',className:'bbb'},'内容'),
  document.getElementById('root')
)

```
## class组件
* ES6写法
  ./scr/inde.js
  ```js
  import React from 'react';
  import ReactDOM from 'react-dom';
  import './01-base/01-class' // 引入自动加载 

  ReactDOM.render(
      React.createElement('div',{id:'app',className:'bbb'},'内容'),
      document.getElementById('root')
  )

  ```
  ./src/0-base/01-class
  ```js
  // ES6写法
  class Test{
    constructor(){
      this.a = 1
    }
    testa(){
      console.log("testa")
    } 
  }
  class ChildTest extends Test{
    testb(){
      console.log("testb")
    }
  }
  // var obj = new Test()
  // obj.testa() // 执行方法 输出testa
  // console.log(obj.a) // 打印属性  1

  var obj = new ChildTest()
  obj.testa() // 执行方法 输出 testa
  console.log(obj.a) // 输出 1

  ```
* ES7 写法
./src/index.js
```js 
import React from 'react';
import ReactDOM from 'react-dom';
import App from './01-base/01-class'
ReactDOM.render(
    <App />,
    document.getElementById('root')
)

```
  ./src/0-base/01-class
```js
// ES7 
// import React from 'react';
// class App extends React.Component{
//   render(){
//     return (
//       <div>1111</div>
//     )
//   }
// } 

import React, { Component } from 'react'
class App extends Component{
render(){
  // renturn () 用括号括起来，表示式回车下的属于一部分的内容
  return (
      <div>
        <h1>1111</h1>
        <ul>
          <li>111</li>
          <li>111</li>
          <li>111</li>
        </ul>
      </div>
  )
}
} 
export default App

```
* 复用组件(推荐)
组件 必须大写开头，否则会报错
为了让代码编写更规范，我们可以下载 插件 `ES7+ React/Redux/React-Native/JS snippets`
./src/index.js
```js
import React from 'react';
import ReactDOM from 'react-dom';
import App from './01-base/01-class'
ReactDOM.render(
    <App />,
    document.getElementById('root')
)
```
  ./src/0-base/01-class
  ```js 
import React, { Component } from 'react'
export default class App extends Component {
  render() {
    return (
      <div>01-class</div>
    )
  }
}

  ```
## 函数组件
16.8之前  无状态组件
16.8   react hooks 
./src/index/j
```js
import React from 'react';
import ReactDOM from 'react-dom';
import App from './01-base/02-fun'
ReactDOM.render(
    <App />,
    document.getElementById('root')
)
```
./src/01-base/02-fun.js
```js
function App(){
  return (
    <div>function Component</div>
  )
}

export default App

```
## 组件嵌套
./src/index.js
```js
import React from 'react';
import ReactDOM from 'react-dom';
import App from './01-base/03-Nesting.js'
ReactDOM.render(
    <App />,
    document.getElementById('root')
)
```
./src/01-base/03-Nesting.js
```js
import React, { Component } from 'react'
class Child extends Component{
  render(){
    return (
      <div>Child Component</div>
    )
  }
}
class Navbar extends Component {
  render(){
    return (
    <div>
      Navbar
      <Child></Child>
    </div>
    )
  }
}
function Swiper(){
  return <div>Swiper</div>
}
// const Tabbar =()=><div>Tabbar</div>
const Tabbar =()=>{
  return <div>Tabbar</div>
}

export default class App extends Component {
  render() {
    return (
      <div>
        {/* 想要在 Navbar 里嵌套子组件， 需要 在Navbar组件放入一个子组件Child，在子组件里写内容 ，而不是在放在<Navbar>标签中*/}
        <Navbar></Navbar>
        <Swiper></Swiper>
        <Tabbar></Tabbar>
      </div>
    )
  }
}

```
## 组件样式
./src/index.js
```js
import React from 'react';
import ReactDOM from 'react-dom';
import './01-base/css/04.css' // y引入外部css样式
import App from './01-base/04-style.js'
ReactDOM.render(
    <App />,
    document.getElementById('root')
)

```
./src/01-base/04-style.js
```js
import React, { Component } from 'react'

export default class App extends Component {
  render() {
    var myname = 'Iekaki'
    // 此样式写仅为演示，项目中不推荐这样使用
    var obj ={
      background:'red', // 需要加入引号
      backgroundColor:'green', // 单一属性需要 写成驼峰写法
      fontSize:'10px'
    }
    return (
      <div>
        {/* 模板语法 */}
        {10+20}
        {/* 变量 */}
        {10+20}- {myname}
        {/* 三目运算 ，加减乘除 ，字符串*/}
        {10>20?'aaa':'bbb'}
        {/* style={} 需要放入一个对象 */}
        <div style={{background:"red"}}>111111</div>
        <div style={obj}>111111</div>
        {/* 属性需要驼峰写法 css样式 需要引入外部css文件*/}
        {/* 另外 class ,for是react的关键字 不可以使用 
        <div class='active'>111111</div>
        <label for='username'>用户名:</label>
        */}
        <div className='active'>111111</div>
        <div id='active'>111111</div>
        <label htmlFor=''>用户名:</label>
        <label htmlFor='username'>用户名:</label>
          <input type="text" id='username'></input>
        
      </div>
    )
  }
}
```
## 事件对象
###  使用
./src/index.js
```js
import React from 'react';
import ReactDOM from 'react-dom';
import App from './01-base/05-event.js'
ReactDOM.render(
    <App />,
    document.getElementById('root')
)

```
./src/01-base/05-event.js
```js
import React, { Component } from 'react'

export default class App extends Component {
  render() {
    return (
      <div>
        05-event
        <input />
        {/* on + 事件类型（注意要写驼峰） */}
        <button onMouseEnter={()=>{
          console.log('onMouseEnter')
        }}>onMouseEnter</button>
        <button onMouseOver={()=>{
          console.log('onMouseEnter')
        }}>onMouseOver</button>

        {/* 无过多逻辑 推荐用法 */}
        <button onClick={()=>{
          console.log('click1')
        }}>add1</button>

        {/* 可以定义在外边  不要加() 画蛇添足 <button onClick={this.handleClick()}></button>*/}
        <button onClick={this.handleClick2}>dd2</button>
        <button onClick={this.handleClick3}>add3</button> 
        {/*组合  逻辑过多 推荐写法*/}
        <button onClick={()=>{
          this.handleClick4()
        }}>add4</button>     
        </div>
    )
  }
  handleClick2(){
    console.log('click2')
  }
  handleClick3=()=>{
    console.log('click3')
  }
  handleClick4=()=>{
    console.log('click3')
  }
}


```
### 事件绑定
./src/01-base/06-eventbind.js
```js
import React, { Component } from 'react'
export default class App extends Component {
  a = 1000
  render() {
    return (
      <div>
        05-event
        <input />
        {/* on + 事件类型（注意要写驼峰） */}
        <button onClick={()=>{
          console.log('click1',this.a)
        }}>add1</button>
        <button onClick={this.handleClick2}>add3</button> 
        <button onClick={this.handleClick.bind(this)}>add-bind不推荐这种写法</button> 
        <button onClick={this.handleClick3}>add3</button> 
        <button onClick={this.handleClick3evt}>SyntheticBaseEvent</button> 
        <button onClick={()=>{
          this.handleClick4()
        }}>add4</button>     
        </div>
    )
  } 
  handleClick2(){
    console.log('click2',this) // click2  undefined
  }
  handleClick(){
    console.log('click2',this.a) // click2  100  绑定 App 的实例
  }
  
  handleClick3=()=>{
    console.log('click3',this.a) // click3  100 箭头函数箭头函数`的this指向指向上下文，所以永久能拿到当前组件实例的this指向
  }
  handleClick3evt=(evt)=>{
    console.log('handleClick3evt',evt,evt.target) // click3  SyntheticBaseEvent  <button>SyntheticBaseEvent</button>
  }
  handleClick4=()=>{
    console.log('click4',this.a) // click4 100 箭头函数，还可以传参
  }
}
/**
 * React 并不会真正的绑定到每一个具体 <> 的元素上，而是采用事件代理的模式:
*/

  // this 的指向 复习
  var obj1 ={
    name:'obj1',
    getName(){
      console.log('obj1')
    }
  }
  var obj2 ={
    name:'obj1',
    getName(){
      console.log('obj1')
    }
  }
  obj1.getName() // obj1
  obj2.getName() // obj2
  obj1.getName.call(obj2) // obj2
  obj1.getName.apply(obj2) // obj2
  obj1.getName.bind(obj2) // 没有打印内容
  obj1.getName.bind(obj2)()  // 自动执行 obj2


```
## Ref 应用
./src/index.js
```js
import React from 'react';
import ReactDOM from 'react-dom';
import App from './01-base/07-ref.js'
ReactDOM.render(
  // 严格模式
  <React.StrictMode>
    <App />
  </React.StrictMode>,
    // <App />,
    document.getElementById('root')
)

```
### 以前的写法
./src/01-base/07-ref.js
```js
import React, { Component } from 'react'
export default class App extends Component {
  render() {
    return (
      <div>
        Ref的应用
        <input ref="mytext"></input>
        <button onClick={()=>{
          // 获取Dom/组件 this.refs.xxx 即将被弃用 严格模式下会报错
          console.log('click',this.refs.mytext,this.refs.mytext.value) // click <input /> 输入的内容
        }}></button>
      </div>
    )
  }
}

```
### 现在的写法
```js
import React, { Component } from 'react'
export default class App extends Component {
  myref= React.createRef() // 返回一个ref对象
  render() {
    return (
      <div>
        Ref的应用
        <input ref={this.myref}></input>
        <button onClick={()=>{
          // 使用 React.createRef()
          console.log("click",this.myref,this.myref.value) // this.myref----{current:input,[[Proptotype]]: Object} 
        }}>点击</button>
        <button onClick={this.handleClick}></button>
        <button onClick={this.handleClick2.bind(this)}></button>
        <button onClick={this.handleClick3}></button>
      </div>
    )
  }
  handleClick(){
    // 这里的 this指向 div 不是 App
    console.log("handleClick ",this.myref,this.myref.value) // undefined
  }
  handleClick2(){
    // 这里的 this指向 App
    console.log("handleClick2 ",this.myref,this.myref.value) // this.myref----{current:input,[[Proptotype]]: Object} 
  }
  handleClick3=()=>{
    // 这里的 this指向 App
    console.log("handleClick3 ",this.myref,this.myref.value) // this.myref----{current:input,[[Proptotype]]: Object} 
  }
}

```

# 组件的数据挂载方式
## state状态
./src/01-base/08-state.js
```js
import React, { Component } from 'react'

export default class App extends Component {
  // state={
  //   mytext:"收藏",
  //   myShow:true
  // }
  // 还可以这样定义state
  constructor(){
    super()
    this.state={
      mytext:"收藏",
      myShow:true,
      myname:'Iekika'
    }
  }
  render() {
    return (
      <div>
        App
        <button onClick={()=>{
          // this.state.mytext = "取消" // 不可以直接修改 state状态
          // 需要这样修改 间接修改
          this.setState({
            mytext:"取消收藏",
            // setState 可以合并修改的状态
            myname:'kkkkk'
          })
        }}>{this.state.mytext}</button>
        {/* 项目中更推荐这种写法 */}
        <button onClick={()=>{
          this.setState({
            myShow:!this.state.myShow
          })
          // 需要对接接口时
          if(this.state.myShow){
            console.log('收藏的逻辑')
          }else{
            console.log("取消收藏的逻辑")
          }
        }}>{this.state.mytext ? "收藏": "取消收藏"}</button>
      </div>
    )
  }
}

```
## 渲染数据
./src/01-base/09-render.js
```js
import React, { Component } from 'react'

export default class App extends Component {
  state={
    // list:["1111","2222","3333"]
    listdata:{
      {id:1,text:"1111"},
      {id:2,text:"2222"},
      {id:3,text:"3333"}
    }
  }
  render() {
    // const newlist = this.state.list.map(item=><li>{item}</li>)
    // 确保节点有一个唯一的标识key，列表的复用和重排，事件的错误绑定，设置key，提高性能
     const newlist = this.state.list.map(item=><li key={item.id}>{item.text}</li>)
    return (
      <div>
        App渲染列表
        <ul>
          {/* 
          这种写法是错误的
          {
            this.state.list.map(item=>
              <li>{item}</li>
              )
          } */}
          {newlist}
          
        </ul>
      </div>
    )
  }
}

```

```