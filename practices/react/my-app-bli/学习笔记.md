# 创建一个react项目

1.进行局部安装

```ssh
 npx create-react-app my-app-bli
 cd my-app-bli
 npm start
```

生成目录：

├──README.md             使用方法的文档
├──node_modules          所有的依赖安装的目录
├──package-lock.json     锁定安装时的包的版本号,保证团队的依赖能保证一致。
├──package.json
├──public                静态公共目录
└──src                   开发用的源代码目录

出现如下信息，表示安装成功:

```ssh
PS F:\学习更多\githubLearn\HTML5-Web\react\practices> npx create-react-app my-app-bli
Need to install the following packages:
  create-react-app
Ok to proceed? (y)
npm WARN deprecated tar@2.2.2: This version of tar is no longer supported, and will not receive security updates. Please upgrade asap.

Creating a new React app in F:\学习更多\githubLearn\HTML5-Web\react\practices\my-app-bli.

Installing packages. This might take a couple of minutes.
Installing react, react-dom, and react-scripts with cra-template...


added 1393 packages in 3m

Installing template dependencies using npm...
npm WARN deprecated source-map-resolve@0.6.0: See https://github.com/lydell/source-map-resolve#deprecated

added 52 packages in 10s
Removing template package using npm...


removed 1 package in 4s

Success! Created my-app-bli at F:\学习更多\githubLearn\HTML5-Web\react\practices\my-app-bli
Inside that directory, you can run several commands:

  npm start
    Starts the development server.

  npm run build
    Bundles the app into static files for production.

  npm test
    Starts the test runner.

  npm run eject
    Removes this tool and copies build dependencies, configuration files
    and scripts into the app directory. If you do this, you can’t go back!

We suggest that you begin by typing:

  cd my-app-bli
  npm start

Happy hacking!

```

2. 删除`src`下的文件，重新新建一个`index.js`文件

```js
// 从 react 的包当中引入了 React。只要你要写 React.js 组件就必须引入React, 因为react里有 一种语法叫JSX，稍后会讲到JSX，要写JSX，就必须引入
React import React from 'react' 
// ReactDOM 可以帮助我们把 React 组件渲染到页面上去，没有其它的作用了。它是从 react-dom 中 引入的，而不是从 react 引入。 
import ReactDOM from 'react-dom' 
// ReactDOM里有一个render方法，功能就是把组件渲染并且构造 DOM 树，然后插入到页面上某个特定的 元素上 
ReactDOM.render( 
  // 这里就比较奇怪了，它并不是一个字符串，看起来像是纯 HTML 代码写在 JavaScript 代码里面。语 法错误吗？这并不是合法的 JavaScript 代码, “在 JavaScript 写的标签的”语法叫 JSX- JavaScript XML。
   <h1>欢迎进入React的世界</h1>, 
   // 渲染到哪里 
   document.getElementById('root') 
)

```

# JSX语法和组件

## 体验JSX语法

```js
import React from 'react';
import ReactDOM from 'react-dom';

//写法一：
ReactDOM.render(
  <div>
    <h1>1111</h1>
    <ul>
      <li>111</li>
      <li>111</li>
      <li>111</li>
    </ul>
  </div>,
  document.getElementById('root')
)
// 写法二:与写法一等效
ReactDOM.render(
React.createElement('div',{id:'app',className:'bbb'},'内容'),
  document.getElementById('root')
)

```

## class组件

* ES6写法
  ./scr/inde.js

  ```js
  import React from 'react';
  import ReactDOM from 'react-dom';
  import './01-base/01-class' // 引入自动加载 

  ReactDOM.render(
      React.createElement('div',{id:'app',className:'bbb'},'内容'),
      document.getElementById('root')
  )
  ```

```

./src/0-base/01-class

​```js
  // ES6写法
  class Test{
    constructor(){
      this.a = 1
    }
    testa(){
      console.log("testa")
    } 
  }
  class ChildTest extends Test{
    testb(){
      console.log("testb")
    }
  }
  // var obj = new Test()
  // obj.testa() // 执行方法 输出testa
  // console.log(obj.a) // 打印属性  1

  var obj = new ChildTest()
  obj.testa() // 执行方法 输出 testa
  console.log(obj.a) // 输出 1

```

* ES7 写法
./src/index.js

```js
import React from 'react';
import ReactDOM from 'react-dom';
import App from './01-base/01-class'
ReactDOM.render(
    <App />,
    document.getElementById('root')
)

```

  ./src/0-base/01-class

```js
// ES7 
// import React from 'react';
// class App extends React.Component{
//   render(){
//     return (
//       <div>1111</div>
//     )
//   }
// } 

import React, { Component } from 'react'
class App extends Component{
render(){
  // renturn () 用括号括起来，表示式回车下的属于一部分的内容
  return (
      <div>
        <h1>1111</h1>
        <ul>
          <li>111</li>
          <li>111</li>
          <li>111</li>
        </ul>
      </div>
  )
}
} 
export default App

```

* 复用组件(推荐)
组件 必须大写开头，否则会报错
为了让代码编写更规范，我们可以下载 插件 `ES7+ React/Redux/React-Native/JS snippets`
./src/index.js

```js
import React from 'react';
import ReactDOM from 'react-dom';
import App from './01-base/01-class'
ReactDOM.render(
    <App />,
    document.getElementById('root')
)
```

./src/0-base/01-class

```js
    import React, { Component } from 'react'
    export default class App extends Component {
      render() {
        return (
          <div>01-class</div>
        )
      }
    }

```

## 函数组件

16.8之前  无状态组件
16.8   react hooks
./src/index/j

```js
import React from 'react';
import ReactDOM from 'react-dom';
import App from './01-base/02-fun'
ReactDOM.render(
    <App />,
    document.getElementById('root')
)
```

./src/01-base/02-fun.js

```js
function App(){
  return (
    <div>function Component</div>
  )
}

export default App

```

## 组件嵌套

./src/index.js

```js
import React from 'react';
import ReactDOM from 'react-dom';
import App from './01-base/03-Nesting.js'
ReactDOM.render(
    <App />,
    document.getElementById('root')
)
```

./src/01-base/03-Nesting.js

```js
import React, { Component } from 'react'
class Child extends Component{
  render(){
    return (
      <div>Child Component</div>
    )
  }
}
class Navbar extends Component {
  render(){
    return (
    <div>
      Navbar
      <Child></Child>
    </div>
    )
  }
}
function Swiper(){
  return <div>Swiper</div>
}
// const Tabbar =()=><div>Tabbar</div>
const Tabbar =()=>{
  return <div>Tabbar</div>
}

export default class App extends Component {
  render() {
    return (
      <div>
        {/* 想要在 Navbar 里嵌套子组件， 需要 在Navbar组件放入一个子组件Child，在子组件里写内容 ，而不是在放在<Navbar>标签中*/}
        <Navbar></Navbar>
        <Swiper></Swiper>
        <Tabbar></Tabbar>
      </div>
    )
  }
}

```

## 组件样式

./src/index.js

```js
import React from 'react';
import ReactDOM from 'react-dom';
import './01-base/css/04.css' // y引入外部css样式
import App from './01-base/04-style.js'
ReactDOM.render(
    <App />,
    document.getElementById('root')
)

```

./src/01-base/04-style.js

```js
import React, { Component } from 'react'

export default class App extends Component {
  render() {
    var myname = 'Iekaki'
    // 此样式写仅为演示，项目中不推荐这样使用
    var obj ={
      background:'red', // 需要加入引号
      backgroundColor:'green', // 单一属性需要 写成驼峰写法
      fontSize:'10px'
    }
    return (
      <div>
        {/* 模板语法 */}
        {10+20}
        {/* 变量 */}
        {10+20}- {myname}
        {/* 三目运算 ，加减乘除 ，字符串*/}
        {10>20?'aaa':'bbb'}
        {/* style={} 需要放入一个对象 */}
        <div style={{background:"red"}}>111111</div>
        <div style={obj}>111111</div>
        {/* 属性需要驼峰写法 css样式 需要引入外部css文件*/}
        {/* 另外 class ,for是react的关键字 不可以使用 
        <div class='active'>111111</div>
        <label for='username'>用户名:</label>
        */}
        <div className='active'>111111</div>
        <div id='active'>111111</div>
        <label htmlFor=''>用户名:</label>
        <label htmlFor='username'>用户名:</label>
          <input type="text" id='username'></input>
        
      </div>
    )
  }
}
```

## 事件对象

### 使用

./src/index.js

```js
import React from 'react';
import ReactDOM from 'react-dom';
import App from './01-base/05-event.js'
ReactDOM.render(
    <App />,
    document.getElementById('root')
)

```

./src/01-base/05-event.js

```js
import React, { Component } from 'react'

export default class App extends Component {
  render() {
    return (
      <div>
        05-event
        <input />
        {/* on + 事件类型（注意要写驼峰） */}
        <button onMouseEnter={()=>{
          console.log('onMouseEnter')
        }}>onMouseEnter</button>
        <button onMouseOver={()=>{
          console.log('onMouseEnter')
        }}>onMouseOver</button>

        {/* 无过多逻辑 推荐用法 */}
        <button onClick={()=>{
          console.log('click1')
        }}>add1</button>

        {/* 可以定义在外边  不要加() 画蛇添足 <button onClick={this.handleClick()}></button>*/}
        <button onClick={this.handleClick2}>dd2</button>
        <button onClick={this.handleClick3}>add3</button> 
        {/*组合  逻辑过多 推荐写法*/}
        <button onClick={()=>{
          this.handleClick4()
        }}>add4</button>     
        </div>
    )
  }
  handleClick2(){
    console.log('click2')
  }
  handleClick3=()=>{
    console.log('click3')
  }
  handleClick4=()=>{
    console.log('click3')
  }
}


```

### 事件绑定

./src/01-base/06-eventbind.js

```js
import React, { Component } from 'react'
export default class App extends Component {
  a = 1000
  render() {
    return (
      <div>
        05-event
        <input />
        {/* on + 事件类型（注意要写驼峰） */}
        <button onClick={()=>{
          console.log('click1',this.a)
        }}>add1</button>
        <button onClick={this.handleClick2}>add3</button> 
        <button onClick={this.handleClick.bind(this)}>add-bind不推荐这种写法</button> 
        <button onClick={this.handleClick3}>add3</button> 
        <button onClick={this.handleClick3evt}>SyntheticBaseEvent</button> 
        <button onClick={()=>{
          this.handleClick4()
        }}>add4</button>     
        </div>
    )
  } 
  handleClick2(){
    console.log('click2',this) // click2  undefined
  }
  handleClick(){
    console.log('click2',this.a) // click2  100  绑定 App 的实例
  }
  
  handleClick3=()=>{
    console.log('click3',this.a) // click3  100 箭头函数箭头函数`的this指向指向上下文，所以永久能拿到当前组件实例的this指向
  }
  handleClick3evt=(evt)=>{
    console.log('handleClick3evt',evt,evt.target) // click3  SyntheticBaseEvent  <button>SyntheticBaseEvent</button>
  }
  handleClick4=()=>{
    console.log('click4',this.a) // click4 100 箭头函数，还可以传参
  }
}
/**
 * React 并不会真正的绑定到每一个具体 <> 的元素上，而是采用事件代理的模式:
*/

  // this 的指向 复习
  var obj1 ={
    name:'obj1',
    getName(){
      console.log('obj1')
    }
  }
  var obj2 ={
    name:'obj1',
    getName(){
      console.log('obj1')
    }
  }
  obj1.getName() // obj1
  obj2.getName() // obj2
  obj1.getName.call(obj2) // obj2
  obj1.getName.apply(obj2) // obj2
  obj1.getName.bind(obj2) // 没有打印内容
  obj1.getName.bind(obj2)()  // 自动执行 obj2


```

## Ref 应用

./src/index.js

```js
import React from 'react';
import ReactDOM from 'react-dom';
import App from './01-base/07-ref.js'
ReactDOM.render(
  // 严格模式
  <React.StrictMode>
    <App />
  </React.StrictMode>,
    // <App />,
    document.getElementById('root')
)

```

### 以前的写法

./src/01-base/07-ref.js

```js
import React, { Component } from 'react'
export default class App extends Component {
  render() {
    return (
      <div>
        Ref的应用
        <input ref="mytext"></input>
        <button onClick={()=>{
          // 获取Dom/组件 this.refs.xxx 即将被弃用 严格模式下会报错
          console.log('click',this.refs.mytext,this.refs.mytext.value) // click <input /> 输入的内容
        }}></button>
      </div>
    )
  }
}

```

### 现在的写法

```js
import React, { Component } from 'react'
export default class App extends Component {
  myref= React.createRef() // 返回一个ref对象
  render() {
    return (
      <div>
        Ref的应用
        <input ref={this.myref}></input>
        <button onClick={()=>{
          // 使用 React.createRef()
          console.log("click",this.myref,this.myref.value) // this.myref----{current:input,[[Proptotype]]: Object} 
        }}>点击</button>
        <button onClick={this.handleClick}></button>
        <button onClick={this.handleClick2.bind(this)}></button>
        <button onClick={this.handleClick3}></button>
      </div>
    )
  }
  handleClick(){
    // 这里的 this指向 div 不是 App
    console.log("handleClick ",this.myref,this.myref.value) // undefined
  }
  handleClick2(){
    // 这里的 this指向 App
    console.log("handleClick2 ",this.myref,this.myref.value) // this.myref----{current:input,[[Proptotype]]: Object} 
  }
  handleClick3=()=>{
    // 这里的 this指向 App
    console.log("handleClick3 ",this.myref,this.myref.value) // this.myref----{current:input,[[Proptotype]]: Object} 
  }
}

```

# 组件的数据挂载方式

## state状态

./src/01-base/08-state.js

```js
import React, { Component } from 'react'

export default class App extends Component {
  // state={
  //   mytext:"收藏",
  //   myShow:true
  // }
  // 还可以这样定义state
  constructor(){
    super()
    this.state={
      mytext:"收藏",
      myShow:true,
      myname:'Iekika'
    }
  }
  render() {
    return (
      <div>
        App
        <button onClick={()=>{
          // this.state.mytext = "取消" // 不可以直接修改 state状态
          // 需要这样修改 间接修改
          this.setState({
            mytext:"取消收藏",
            // setState 可以合并修改的状态
            myname:'kkkkk'
          })
        }}>{this.state.mytext}</button>
        {/* 项目中更推荐这种写法 */}
        <button onClick={()=>{
          this.setState({
            myShow:!this.state.myShow
          })
          // 需要对接接口时
          if(this.state.myShow){
            console.log('收藏的逻辑')
          }else{
            console.log("取消收藏的逻辑")
          }
        }}>{this.state.mytext ? "收藏": "取消收藏"}</button>
      </div>
    )
  }
}

```

## 渲染数据

./src/01-base/09-render.js

// # 创建一个react项目

1.进行局部安装

```ssh
 npx create-react-app my-app-bli
 cd my-app-bli
 npm start
```

生成目录：
├──README.md             使用方法的文档
├──node_modules          所有的依赖安装的目录
├──package-lock.json     锁定安装时的包的版本号,保证团队的依赖能保证一致。
├──package.json
├──public                静态公共目录
└──src                   开发用的源代码目录

出现如下信息，表示安装成功:

```ssh
PS F:\学习更多\githubLearn\HTML5-Web\react\practices> npx create-react-app my-app-bli
Need to install the following packages:
  create-react-app
Ok to proceed? (y)
npm WARN deprecated tar@2.2.2: This version of tar is no longer supported, and will not receive security updates. Please upgrade asap.

Creating a new React app in F:\学习更多\githubLearn\HTML5-Web\react\practices\my-app-bli.

Installing packages. This might take a couple of minutes.
Installing react, react-dom, and react-scripts with cra-template...


added 1393 packages in 3m

Installing template dependencies using npm...
npm WARN deprecated source-map-resolve@0.6.0: See https://github.com/lydell/source-map-resolve#deprecated

added 52 packages in 10s
Removing template package using npm...


removed 1 package in 4s

Success! Created my-app-bli at F:\学习更多\githubLearn\HTML5-Web\react\practices\my-app-bli
Inside that directory, you can run several commands:

  npm start
    Starts the development server.

  npm run build
    Bundles the app into static files for production.

  npm test
    Starts the test runner.

  npm run eject
    Removes this tool and copies build dependencies, configuration files
    and scripts into the app directory. If you do this, you can’t go back!

We suggest that you begin by typing:

  cd my-app-bli
  npm start

Happy hacking!

```

2. 删除`src`下的文件，重新新建一个`index.js`文件

```js
// 从 react 的包当中引入了 React。只要你要写 React.js 组件就必须引入React, 因为react里有 一种语法叫JSX，稍后会讲到JSX，要写JSX，就必须引入
React import React from 'react' 
// ReactDOM 可以帮助我们把 React 组件渲染到页面上去，没有其它的作用了。它是从 react-dom 中 引入的，而不是从 react 引入。 
import ReactDOM from 'react-dom' 
// ReactDOM里有一个render方法，功能就是把组件渲染并且构造 DOM 树，然后插入到页面上某个特定的 元素上 
ReactDOM.render( 
  // 这里就比较奇怪了，它并不是一个字符串，看起来像是纯 HTML 代码写在 JavaScript 代码里面。语 法错误吗？这并不是合法的 JavaScript 代码, “在 JavaScript 写的标签的”语法叫 JSX- JavaScript XML。
   <h1>欢迎进入React的世界</h1>, 
   // 渲染到哪里 
   document.getElementById('root') 
)

```

# 表单中的受控组件与非受控组件

## 1.非受控组件

React 要编写一个非受控组件，可以使用ref来从DOM节点中获取表单数据,就是非受控组件.

例如，下面的代码使用非受控组件接受一个表单的值：

```js
class NameForm extends React.Component { 
  constructor(props) { 
    super(props); this.handleSubmit = this.handleSubmit.bind(this); 
    this.input = React.createRef(); 
  }
handleSubmit(event) { 
  alert('A name was submitted: ' + this.input.current.value); 
  event.preventDefault(); }
  render() { 
    return ( 
      <form onSubmit={this.handleSubmit}> 
        <label> Name: 
          <input type="text" ref={this.input} /> 
        </label> 
        <input type="submit" value="Submit" /> 
      </form> ); 
    } 
    }

```

因为非受控组件将真实数据储存在 DOM 节点中，所以在使用非受控组件时，有时候反而更容易同时集成 React 和非 React 代码。如果你不介意代码美观性，并且希望快速编写代码，使用非受控组件往往可以减少你的代码量。否则，你应该使用受控组件。


**默认值**

在 React 渲染生命周期时，表单元素上的 value 将会覆盖 DOM 节点中的值，在非受控组件中，你经常希望 React 能赋予组件一个初始值，但是不去控制后续的更新。 在这种情况下, 你可以指定一个defaultValue 属性，而不是 value 。


```jsx
render() {
  return (
    <form onSubmit={this.handleSubmit}> 
    <label> Name: 
      <input defaultValue="Bob" type="text" ref={this.input} /> 
    </label> 
    <input type="submit" value="Submit" /> 
    </form> 
  ); 
  }

```


同样， `<input type="checkbox">` 和 `<input type="radio">` 支持 **`defaultChecked`** ， `<select>` 和 `<textarea>` 支持 **`defaultValue`** 。


## 受控组件

```jsx
    class NameForm extends React.Component {  
      constructor(props) {    
        super(props);    
        this.state= {value: ''};
        this.handleChange=this.handleChange.bind(this);    
        this.handleSubmit=this.handleSubmit.bind(this);  
      }
      handleChange(event) {    
        this.setState({value: event.target.value});  
      }
      handleSubmit(event) {    
        alert('提交的名字: '+this.state.value);    
        event.preventDefault();  
      }
      render() {    
        return (      
          <form onSubmit={this.handleSubmit}>        
          <label> 名字:      
             <input type="text"value={this.state.value} onChange={this.handleChange} />
          </label>  
           <input type="submit"value="提交"/> 
           </form>
              ); 
      }
    }
```


由于在表单元素上设置了`value`属性，因此显示的值将始终为`this.state.value`,这使得React的state成为唯一的数据源。由于`handelchange`在每次按键是都会执行并更新React的state，因此显示的值将随着用户输入而更新。


对于受控组件来说，输入的值始终由React的state驱动，你也可以将value传递给其他UI元素，或者其他事件处理函数重置，但这意味着你需要编写更多的代码。

> 注意：另一种说法(广义范围的说法),React组件的数据渲染是否被调用者传递的props完全控制，控制则为受控组件，否则非受控组件。



# 组件的通信方式


## 父子组件通信方式

(1)传递数据(父传子)与传递方法(子传父)
(2)ref标记(父组件拿到子组件的引用，从而调用子组件的方法)
  在父组件中清除子组件的input输入框的value值。this.refs.from.reset()

## 非父子组件的通信方式

(1) 状态提升(中间人模式)
   React中的状态提升概括来说，就是多个组件需要共享的状态提升到它们最近的父组件上，在父组件上改变这个状态然后通过props分发给子组件。
(2) 发布订阅模式实现
(3) context状态数传参

```jsx
  //  a.先定义全局context对象
  import React from 'react'
  const GlobalContext = React.createContext()
  export default GlobalContext
```

```jsx
  //  b.根组件引入GlobalContext，并使用GlobalContText.Provider(生产者)
  // 重新包装根组件 class App()
  <GlobalContext.Provider
  value={{
    name:'Iekika',
    age:18,
    content:this.state.content,
    show:this.show.bind(this),
    hide:this.hide.bind(this)
  }}
  >
  </GlobalContext.Provider>

```

```jsx
    //  c.任意组件引入 GlobalContext 并调用context,使用GlobalConntext.Consumer(消费者)
    <GlobalContext>
    {
    context=>{
      this.myshow = = context.show // 可以在当前组件任意函数触发
      this.myhide = context.hide; // 可以在当前组件任意函数触发 
      return (
        <div>
        {context.name}-{context.age}-{context.context}
        </div>
      )
    }
    }
    </GlobalContext>
```


 注意： `GlobalContext.Consumer` 内必须是 ** 回调函数 **，通过context方法改变根组件状态

> context 优缺点:
> 优点:跨组件访问数组
> 缺点: react组件树种某个上级组件shouldComponentUpdate返回false，当context更新时，不会引起下级组件的更新。

## 代码案例
1. 父子组件通信方式
   * 传递数据(父传子)与传递方法(子传父)
        > ./scr/02-advanced/01-ChildPropsParent.js
        >
        > ```jsx
        > import React, { Component } from 'react'
        > 
        > class Navbar extends Component{
        > render(){
        > return <div style={{background:"red"}}>
        >   <button onClick={()=>{
        >     console.log("子通知符，让父的isShow 取反",this.props.event)
        >     this.props.event() // 调用父组件的函数
        >   }}>click</button>
        >   <span>navbar</span>
        > </div>
        > }
        > }
        > class Sidebar extends Component{
        > render(){
        >   return <div style={{background:"yellow",width:"200px"}}> 
        >       <ul>
        >           <li>11111</li>
        >           <li>11111</li>
        >           <li>11111</li>
        >           <li>11111</li>
        >           <li>11111</li>
        >           <li>11111</li>
        >       </ul>
        >   </div>
        > }
        > }
        > export default class App extends Component {
        > state={
        > isShow:false
        > }
        > handleEvent=()=>{
        > this.setState({
        >   isShow:!this.state.isShow
        > })
        > console.log("父组件定义的event事件")
        > }
        > render() {
        > return (
        > 
        >   <div>
        >     {/* <Navbar event={()=>{
        >       // this.setState({
        >       //   isShow:!this.state.isShow
        >       // })
        >       console.llog("父组件定义的event事件")
        >     }}></Navbar> */}
        >     <Navbar event={this.handleEvent} />
        >     {this.state.isShow && <Sidebar></Sidebar>}
        >   </div>
        > 
        > )
        > }
        > }
        > /**
        > 
        > * 父传子 ： 属性
        > * 子传父 ：回调函数callback
        >   */
        > ```
   * ref 标记
   
        > ./src/02-advanced/05-RefNameFrom.js
        >
        > ```jsx
        > import React, { Component } from 'react'
        > // 一个简单的Antd 的Filed组件原理
        > class Filed extends Component{
        >     state={
        >     value:""
        >     }
        >     clear(){
        >         this.setState({
        >         value:""
        >         })
        >     }
        >     setVlaue(val){
        >         this.setState({
        >         value:val
        >         })
        >     }
        >     render(){
        >         return (
        >         // 受控组件
        >         <div style={{background:"yellow"}}>
        >           <lable>{this.props.label}</lable>
        >           <input type={this.props.type} onChange={(evt)=>{
        >             this.setState({
        >               value:evt.target.value
        >             })
        >           }} value={this.state.value}/>
        >         </div>
        >         )
        >     }
        > }
        > 
        > export default class App extends Component {
        >     username = React.createRef()
        >     password = React.createRef() 
        >     render() {
        >         return (
        >         <div>
        >           <h1>登录页面</h1>
        >           <Filed label="用户名" type="text" ref={this.username}></Filed>
        >           <Filed label="密码" type="password" ref={this.password}></Filed>
        >           <button onClick={()=>{
        >             console.log('拿到当前DOM/组件实例',this.username.current)
        >               console.log(this.username.current.state.value,this.password.current.state.value)
        >           }}>登录</button>
        >           <button onClick={()=>{
        >             this.username.current.clear()
        >             this.password.current.clear()
        >           }}>取消保存</button>
        >         </div>
        >         )
        >     }
        > }
     > ```
   
2. 非父子组件的通信方式

   * 状态提升(中间人模式)
     
    > ![](https://i0.hdslb.com/bfs/album/a76ae98199981386be6233aab5e8fbcc49b47b37.png)
    > ./src/02-advanced/06-intermediary.js
    >     ```jsx
    > import React, { Component } from 'react'
    > import axios from 'axios'
    > import './css/maizuo.css'
    > export default class App extends Component {
    >   constructor() {
    >     super()
    >     this.state = {
    >       filmList: [],
    >       info:''
    >     }
    >     axios.get(`test.json`).then(res => {
    >       console.log(res.data.data.films)
    >       this.setState({
    >         filmList: res.data.data.films
    >       })
    >     })
    >   }
    >   render () {
    >     return (
    >       <div>
    >         {
    >           this.state.filmList.map(item =>
    >             <FilmItem key={item.filmId} {...item} onEvent={(value)=>{
    >               console.log("父组件接收value",value)
    >               this.setState({
    >                 info:value 
    >               })
    >             }}></FilmItem>
    >           )
    >         }
    >         <FilmDetail info={this.state.info}></FilmDetail>
    >       </div>
    >     )
    >   }
    > }
    > 
    > // 受控组件
    > class FilmItem extends Component {
    >   render () {
    >     console.log('FilmList', this.props)
    >     const { name, poster,grade,synopsis } = this.props
    >     return <div className='filmitem' onClick={()=>{
    >       this.props.onEvent(synopsis) // 调用父组件并传入数据
    >     }}>
    >       <img src={poster} alt={name}></img>
    >       <h4>{name}</h4>
    >       <div>观众评分：{grade}</div>
    >     </div>
    >   }
    > }
    > 
    > class FilmDetail extends Component {
    >   render(){
    >     return <div className='filmdetail'>
    >       {this.props.info}
    >     </div>
    >   }
    > }
    >     ```
   
   * 发布订阅模式实现
   
      
    > ![](https://i0.hdslb.com/bfs/album/00b4c73b3861e952183a00dd66b06eedde1b1c65.png)
    > ![](https://i0.hdslb.com/bfs/album/38b690096717d0c9a6fd97e436acb60bb620216e.png)
    > ```jsx
    > import React, { Component } from 'react'
    > import axios from 'axios'
    > import './css/maizuo.css'
    > 
    > // 调度中心
    > var bus ={
    >   list:[],
    >   //订阅
    >   subscribe(callback){
    >     this.list.push(callback)
    >   },
    >   // 发布
    >   publish(text){
    >     this.list.forEach(callback=>{
    >       callback && callback(text)
    >     })
    >   }
    > }
    > 
    > export default class App extends Component {
    >   constructor() {
    >     super()
    >     this.state = {
    >       filmList: []
    >     }
    >     axios.get(`test.json`).then(res => {
    >       console.log(res.data.data.films)
    >       this.setState({
    >         filmList: res.data.data.films
    >       })
    >     })
    >   }
    >   render () {
    >     return (
    >       <div>
    >         {
    >           this.state.filmList.map(item =>
    >             <FilmItem key={item.filmId} {...item} ></FilmItem>
    >           )
    >         }
    >         <FilmDetail></FilmDetail>
    >       </div>
    >     )
    >   }
    > }
    > 
    > // 受控组件
    > class FilmItem extends Component {
    >   render () {
    >     console.log('FilmList', this.props)
    >     const { name, poster,grade,synopsis } = this.props
    >     return <div className='filmitem' onClick={()=>{
    >       console.log(synopsis)
    >       bus.publish(synopsis)
    >     }}>
    >       <img src={poster} alt={name}></img>
    >       <h4>{name}</h4>
    >       <div>观众评分：{grade}</div>
    >     </div>
    >   }
    > }
    > 
    > class FilmDetail extends Component {
    >   constructor(){
    >     super()
    >     this.state={
    >       info:''
    >     }
    >     bus.subscribe((info)=>{
    >       console.log("我再filmDetail中定义",info)
    >       this.setState({
    >         info:info
    >       })
    >     })
    >   }
    >   render(){
    >     return <div className='filmdetail'>
    >       {this.state.info}
    >     </div>
    >   }
    > }
    > ```

  * context
        > ![](https://i0.hdslb.com/bfs/album/4d8b21f9cc949bc804ed9398cbe5eeb16216a945.png)
        > ./src/02-advanced/09-context.js
        >
        > ```jsx
        >   import React, { Component } from 'react'
        >   import axios from 'axios'
        >   import './css/maizuo.css'
        > 
        >   const GlobalContext = React.createContext() // 创建context上下文对象
        >   export default class App extends Component {
        >     constructor() {
        >       super()
        >       this.state = {
        >         filmList: [],
        >         info:''
        >       }
        >       axios.get(`test.json`).then(res => {
        >         console.log(res.data.data.films)
        >         this.setState({
        >           filmList: res.data.data.films
        >         })
        >       })
        >     }
        >     render () {
        >       return (
        >         // GlobalContext.Provider 供应商组件
        >         <GlobalContext.Provider value={
        >           {
        >             call:"打电话",
        >             sms:"短信",
        >             info:this.state.info,
        >             changeInfo:(val)=>{
        >               this.setState({
        >                 info:val
        >               })
        >             }
        >           }
        >         }>
        >           <div>
        >             {
        >               this.state.filmList.map(item =>
        >                 <FilmItem key={item.filmId} {...item} ></FilmItem>
        >               )
        >             }
        >             <FilmDetail></FilmDetail>
        >           </div>
        >         </GlobalContext.Provider>
        >       )
        >     }
        >   }
        > 
        >   // 受控组件
        >   class FilmItem extends Component {
        >     render () {
        >       console.log('FilmList', this.props)
        >       const { name, poster,grade,synopsis } = this.props
        >       return (  
        >         <GlobalContext.Consumer>
        >           {
        >             (value)=>{
        >               console.log(value)
        >               return <div className='filmitem' onClick={()=>{
        >                 console.log(synopsis)
        >                 value.changeInfo(synopsis)
        >                 }}>
        >                 <img src={poster} alt={name}></img>
        >                 <h4>{name}</h4>
        >                 <div>观众评分：{grade}</div>
        >               </div>
        >             }
        >           }
        >       </GlobalContext.Consumer>
        >       )
        >     }
        >   }
        > 
        >   class FilmDetail extends Component {
        >     render(){
        >       return (
        >         <GlobalContext.Consumer>
        >         {
        >           // (value)=>{
        >           //    return <div className='filmdetail'>
        >           //     {value.info}
        >           //   </div>
        >           // }
        >           (value)=><div className='filmdetail'>
        >             {value.info}
        >           </div>
        >           }
        >         </GlobalContext.Consumer>
        >       )
        >     }
        > }
        > ```
        >
        > 
      
* 插槽

  > ./src/02-advanced/10-slot.js
  >
  > ```jsx
  > import React, { Component } from 'react'
  > 
  > class Child extends Component{
  >     render(){
  >         return <div>
  >             child
  > 
  >             {/* 插槽 vue slot,具名插槽 */}
  > 
  >             {this.props.children[2]}
  >             {this.props.children[1]}
  >             {this.props.children[0]}
  >         </div>
  >     }
  > }
  > 
  > class Swiper extends Component{
  >     render(){
  >         return <div>
  >             {this.props.children}
  >         </div>
  >     }
  > }
  > 
  > export default class App extends Component {
  >     render() {
  >         return (
  >             <div>
  > 
  >                 <Swiper>
  >                     <div>111111</div>
  >                     <div>222222</div>
  >                     <div>333333</div>
  >                 </Swiper>
  >                 <Swiper>
  >                     {/* <div><img/>111111</div>
  >                     <div><img/>222222</div>
  >                     <div><img/>333333</div> */}
  >                 </Swiper>
  >                 <Swiper>
  >                     {/* <img/>
  >                     <img/>
  >                     <img/> */}
  >                 </Swiper>
  > 
  >                 
  >                 <Child>
  >                     <div>11111111</div>
  >                     <div>22222222</div>
  >                     <div>33333333</div>
  >                     {
  >                         // children
  >                     }
  >                 </Child>
  >             </div>
  >         )
  >     }
  > }
  > 
  > 
  > /*
  >   1. 为了复用
  >   2. 一定程度减少父子通信。
  > */
  > 
  > ```
  >
  > 

# React 生命周期

## 1. 初始化阶段

* componentWillMount: render 之前最后一次修改状态的机会<font color=red>已废弃</font>   - 加上前缀才不会报错UNSAFE_componentWillMount
* render:只能访问`this.props`和`this.state`,不允许修改状态和DOM输出
* componentDidMount:成功render并渲染完成真实DOM之后触发，可以修改DOM

## 2.运行中阶段

* componentWillReceivePorps:父组件修改属性触发 <font color=red>已废弃</font>
* shouldComponentUpdate:返回false会阻止render调用
* componentWillUpdate:不能修改属性和状态
* render:只能访问this.props和this.state,不允许修改状态和DOM输出
* componentDidUpdate:可以修改DOM

## 销毁阶段

* componentWillUnmount:在删除组件之前清理操作，比如计时器和事件监听器

## 老生命周期的问题

(1) componentWillMount ,在ssr中 这个方法将会被多次调用， 所以会重复触发多遍，同时在这里如果绑定事件，
将无法解绑，导致内存泄漏 ， 变得不够安全高效逐步废弃。

(2) componentWillReceiveProps 外部组件多次频繁更新传入多次不同的 props，会导致不必要的异步请求

(3) componetWillupdate, 更新前记录 DOM 状态, 可能会做一些处理，与componentDidUpdate相隔时间如果过长，会导致 状态不太信

## 新生命周期的替代

(1) getDerivedStateFromProps:第一次的初始化组件以及后续的更新过程中(包括自身状态更新以及父传子),返回一个对象作为新的state，返回null则说明不需要在这里更新state
> 初始化时候 可以替代 componentWillMount
> 父传子的时候 可以替代 componentWillReceivedProps

```js
// 老的生命周期
componentDidMount(){
  if(this.props.value !== undefined){
    this.setState({
      current:this.props.value
    })
  }
}
componentWillReceivePorps(nextProps){
  if(nextProps.value !== undefined){
    this.setState({
      current:nextProps.value
    })
  }
}
// 新的生命周期写法
static getDerivedStateFromProps(nextProps){
  if(nextProps.value !== undefined){
    return {
      current:nextProps.value
    }
  }
  return null
}

```

(2) getSnapshotBeforeUpdate 取代了componentWillUpdate，触发事件为update发生的时候，在render之后dom渲染之前返回一个值，作为**componentDidUpdate**的第三个参数。

```js
// 新的数据不断插入数据前面，导致我正在看的数据往下走，如何保持可视图依旧是我之前看到的数据呢?
getSnapshotBeforeUpdate(){
  return this.refs.wrapper.scrollHeight
}
componentDidUpdate(prevProps,prevState,preHeight){
  // if(preHeight===200)return ;
  this.refs.wrapper.scrollTop +=this.refs.wrapper.scrolHeight-preHeight
}
<div style={{height:"200px",overflow:"auto"}}} ref="wrapper"> <ul>......... </ul> </div>
```

**shouldComponentUpdate**优化性能的案例

```js
import React, { Component } from 'react'

class Box extends Component{
  // 加上优化性能
  shouldComponentUpdate(nextProps, nextState) {
    if(this.props.current === this.props.index || nextProps.current===nextProps.index){
      return true
    }
    return false // 返回false 阻止render调用
  }
  render(){
    // return <div style={{width:"100px",height:"100px",border:"1px solid gray",margin:"10px",float:"left"}}></div>
    return <div style={{width:"100px",height:"100px",border:this.props.current === this.props.index?"1px solid #64de64":"1px solid gray",margin:"10px",float:"left"}}></div>
  }
}
export default class App extends Component {
  state={
    list:["00","01","02","03","04","05","06","07","08","09"],
    current:0
  }
  render() {
    return (
      <div>
        <input type="number" onChange={(evt)=>{
          this.setState({
            current:Number(evt.target.value)
          })
        }} value={this.state.current}></input>
        <div style={{overflow:"hidden"}}>
          {
            this.state.list.map((item,index)=>
              <Box key={item} current={this.state.current} index={index}></Box>
              )
          }

        </div>
        <Box></Box>
      </div>
    )
  }
}

```

## react中性能优化的方案

1. shouldComponentUpdate
控制组件自身或子组件是否更新，尤其在子组件非常多的情况下，需要进行优化。
2. PureComponent
PureComponent会帮你 比较新props 跟 旧的props， 新的state和老的state（值相等,或者对象含有相同的属性、且属性值相等 ），决定shouldcomponentUpdate 返回true 或者false， 从而决定要不要呼叫 render function。
注意：
如果你的 state 或 props 『永远都会变』，那 PureComponent 并不会比较快，因为
 shallowEqual 也需要花时间。

# React Hooks

## 使用hooks 理由

1. 高阶组件为了复用，导致代码层级复杂
2. 生命周期的复杂
3. 写成function组件，无状态组件 ，因为需要状态，又改成了class成本高

### useState(保存组件状态)

```js
const [state,setState] = useState(initialState)
```

### useEffect(处理副作用)和useLayoutEffect(同步执行副作用)

Function Component 不存在生命周期，所以不要把Class Component的生命周期概念搬过拉力试图对号入座。

```js
useEffect(()=>{
  // effect
  return ()=>{
    // cleanup
  }
},[依赖的状态;空数组,表示不依赖])
```

**不要对Dependencles撒谎，如果你明明使用了某个变量，却，没有申明在依赖中，你等于向React撒了谎，后果就是，当依赖的变量改变时，useEffect也不会再次执行，eslint会报错**
PreView页面改造成函数式组件，在路径上从id=1切换到id=2也会自动重新加载，比class组件方便

```js
let id=props.match.params.myid 
useEffect(()=>{
  axios.get(`/articles/${id}`).then(res=>{
    settitle(res.data.title)
    setcontent(res.data.content)
    setcategory(res.data.category)
  })
})
```

useEffect和useLayout有什么区别?
**简单来说就是调用时机不同， useLayoutEffect 和原来 componentDidMount & componentDidUpdate 一致，在react完成DOM更新马上同步调用的代码，会阻塞页面渲染。而 useEffect 是会在整个页面渲染完才会调用的代码**
官方建议优先使用 useEffect
> However, we recommend starting with useEffect first and only trying useLayoutEffect if that causes a problem.

在实际使用时如果想要避免**页面抖动**(在`useEffect`里修改DOM很有可能出现)的话，可以把需要操作DOM的代码放在`useLayoutEffect`里。在这里做点dom操作，这dom修改会和react做出的更改一起被一次性渲染到屏幕上，只有一次回流、重绘的代价。

### useCallback(记忆函数)

*防止因为组件重新渲染，导致方法被重新创建，气到缓存作用，只有第二个参数变化了，才重新声明一次*

```js
var handleClick = useCallback(()=>{
  console.log(name)
},[name])
<button onClick={()=>handleClick()}>click</button>

// 只有name改变后，这个函数才会重新声明一次。
// 如果传入空数组，那么就是第一次创建后就被缓存，如果name后期改变了，拿到的还是老的name。
// 如果不传入第二个参数，每一次都会重新声明一次，拿到的就是最新的name。
```

### useMemo 记忆组件

useCallback 的功能完全可以由useMemo所取代，如果你想要通过使用useMemo返回一个记忆函数也是完全的。

```js
useCallback(fn,input) is equivalent to useMemo(()=>fn, inputs)
```

唯一的的区别是:**useCallback不会执行第一个参数函数，而是将它返回给你，而是useMemo会执行第一个函数并且将函数执行结果返回给你。**所以在前面的例子汇总，可以返回handleClick来达到存储函数的目的。
所以useCallback常用记忆事件函数，生成记忆后的事件函数并传递给子组件使用。而useMemo更适合经过函数计算得到一个确定的值，比如记忆组件。

### useRef(保存引用值)

```js
const myswiper = useRef(null);
<Swiper ref={myswiper} />
```

### useReducer 和 useContext(减少组件层级)

```js
import React from 'react'
var GlobalContext = React.createContext()
// 注意此时的reducer 返回值是一个对象 {isShow:false,list:[]}
function App(){
    let [state,dispatch] = useReducer(reducer,{isShow:true,list:[]})
    return <GlobalContext.Provider value={{
                dispatch
            }}>
              <div>
              {
                  state.isShow?<div>我是选项卡</div>:null
              }
              {props.children}
              </div>
            </GlobalContext.Provider>
}

function Detail(){
    var [dispatch] = useContext(GlobalContext)
    useEffect(()=>{
        // 隐藏
        dispatch({
            type:"Show",
            payload:false
        })
        return ()=>{
            // 显示
            dispatch({
                type:"Show",
                payload:true
            })
        }
    },[])
    return <div>detail</div>
}
```

#### 自定义hooks

**当我们想在两个函数之间共享逻辑时，我们会把它提取到到三个函数中。**
必须以`use`开头吗？<font color=red>必须如此</font>。这个约定非常重要，不遵循的话，由于无法判断某个函数是否包含对其内部Hook的调用，React将无法自动检查你的Hook是否违反了Hook的规则。

# React Router(react-route-dom@6)

## 官方文档

> [**React Router 官方文档**](https://reactrouter.com/docs/en/v6)
>
## 安装

运行以下命令安装React-Router

```ssh
npm install react-router-dom@6
```

<font color=red>注意:</font>`react-router-dom`包含所有内容，导入组件是应该从`react-router-dom`中导入，而不应该从`react-router`中导入，否则，会意外地应用中导入不匹配的库版本;

## 基本用法

### **在web应用程序中开启 React router功能**

`index.js`

```js
import React from 'react';
import {createRoute} from 'react-dom/client';
import {BrowserRouter} from 'react-route-dom'
import App from './App'

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
// Connect the URl 通过在应用入口添加 BrowserRouter 组件开启React Route 功能
<BrowserRouter>
    <React.StrictMode>
      <App />
    </React.StrictMode>
</BrowserRouter>
```

<font color=red>注意：</font>web应用程序中一般使用`BrowserRouter`组件，还用另一种`HashRouter`组件方式；
这两种方式的区别:

1. 底层原理不一样：
    `BrowserRouter`调用的是**H5 history API**，低版本兼容性问题
    `HashRouter`使用的是**URL**哈希值；
2. 地址栏表现形式不一样
   `BrowserRouter`的路径: localhost:3000/index
   `HashRouter`的路径:locahost:3000/#/index
3. 刷新后对路由**state**参数的影响
   `BrowserRouter`没有任何影响，应为**state**保存在history对象中
   `HashRouter`刷新后会导致路由**state**参数的丢失
值得注意的是，官方强烈建议不要使用`HashRouter`;

### 配置路由

`./App.js`

```js
// 导入Route，Routes组件
import {Route,Routes} from 'react-router-dom'
export default function App(){
    return(
      <Routes>
      {/* Add some Routes*/}
      {/** 页面默认导航到 Home组件(页面上显示 Home Component)*/}
      <Route path='/' element={<Home />}
      {/* 在地址栏输入 localhost:3000/about 导航到 About组件(页面上显示 About Component）*/}
      <Route path='/about' element={<About />}
      <Routes>
    )
}

const Home=(props)=>{
    return <div>Home Componet</div>
}
const About=(props)=>{
    return <div>About Component</div>
}
```

在以前的版本 **React Router**中，必须以某种方式对路由进行排序，以便在多个路由与不明确的**URL**匹配时获得要呈现的正确路由，V6更智能，会选择最具体的匹配；

### 添加 “不匹配”路由

`./App.js`

```js
import {Route,Routes} from 'react-router-dom';
export default function App(){
    return(
    <Routes>
      <Route path='/' element={<Home />}/>
      <Route path='about' element={<About />} />
      {/* Adding a "No Match" Route 当没有其他路由与 URL 匹配时，匹配 path=‘*’的路由*/}
      <Route path='*' element={<NotFount />} />
    <Routes>
    )
}
const Home = (props) => {
  return <div>Home Compontent</div>;
}

const About = (props) => {
  return <div>About Compontent</div>;
}

const NotFount = (props) => {
  return <div>NotFount !!!</div>;
}
```

当没有其他路由与URL匹配时，才会`path='*'`路由。此路由将匹配任何URL，但优先级最弱，因为此路由器仅在没有其他路由匹配时才会选择它；

## 使用链接导航

`./App.js`

```js
// 导入Link 组件
import {Route,Routes} from 'react-router-dom';
export default function App(){
    return(
    <Routes>
      {/* 页面默认导航到 Home 组件(渲染 Home 组件, 页面显示 HomeCompontent 链接) */}
      <Route path='/' element={<Home />}/>
      <Route path='about' element={<About />} />
      <Route path='*' element={<NotFount />} />
    <Routes>
    )
}
const Home = (props) => {
  return <div>
      Home Compontent
      {/*点击About Link 链接跳转至 http://localhost:3000/about 
      画面显示 About 组件内容---(Home Link链接)
      */}
      <Link to='/about'>About Link</Link>
  </div>;
}

const About = (props) => {
  return <div>
      About Compontent
      {/*点击About Link 链接跳转至 http://localhost:3000/about 
      画面显示 Home 组件内容---(About Link链接) */}
       <Link to='/'>Home Link</Link>
  </div>;
}

const NotFount = (props) => {
  return <div>NotFount !!!</div>;
}
```

### 使用嵌套路由

`./App.js`

```js
// 导入Link，OutLet组件
import {Route,Routes,Link,Outlet} from 'react-router-dom'
export default function App(){
    return (
       <Routes>
      {/* 页面默认导航到 Home 组件(渲染 Home 组件, 页面显示 Home Compontent 链接) */}
       {/* Nested Routes*/}
      <Route path='/' element={<Home />}>
          <Route path='about' element={<About />} />
          <Route path='setting' element={<Setting />} />
          {/* 默认子路由 如果导航栏地址为 http://localhost:3000 , 此时子路由渲染位置(Outlet)为空白，增加一下配置，子路由渲染位置(Outlet)渲染 */}
           {/*Index Routes*/}
          <Route index element={<List />}/>
          <Route path='*' element={<NotFount />} />
      </Route>
    <Routes>
    )
}
const Home=(props)=>{
    return (
      <>
      <div>
          <Link to='/about'>About Link</Link> | {' '}
          <Link to='/setting'>Setting Link</Link>
      </div>
      <div style={{padding:'20px',margin:'10px',borderTop:'1px solid'}}>
          {/*Outlet 为嵌套子路由的出口，比如：点击About Link链接，
          浏览器地址变为 http://loalhost:3000/about 
          在此渲染路由地址 /about 的组件(在此显示：About Component)
          */}
          <Outlet />
      </div>
      
      </>
    )
}
const About = (props) => {
  return <div>
    About Compontent
  </div>;
}

const Setting = (props) => {
  return <div>
    Setting Compontent
  </div>;
}

const List = (props) => {
  return <div>
    List Compontent
  </div>;
}
```

这里**React Router**最强大的功能之一，在实际开发中，大多数UI都是一系列嵌套布局，**React Router**通过这种嵌套路由的方式实现了一些自动、持久的布局处理:

### 使用活动链接

`./App.js`

```js
// 导入NavLink组件
import {Route,Routes,NavLink,Outlet} from 'react-router-dom'
export default function App(){
   return (
    <Routes>
      <Route path='/' element={<Home />} >
        <Route path='about' element={<About />} />
        <Route path='setting' element={<Setting />} />
        <Route index element={<List />} />
      </Route>
    </Routes>
   );
}
const Home=(props)=>{
    return <>
      <div>
      {/* <NavLink /> 接收一个style或者 className 属性
      属性值为一个回调函数，可以通过 isActive的值判断
      链接是否处于活动状态，从而实现给活动链接添加样式的效果
      实例效果：点击哪个链接，目标链接字体变红
      */}
      <NavLink style={({isActive})=>navColor(isActive)} to='/about'>
        About LInk
      </NaLink> ?? {' '}
      <NavLink style={({isActive})=>navColor(isActive)} to='/setting'>
      Setting Link
      </NavLink>
      </div>
       <div style={{ padding: '20px', margin: '10px', borderTop: '1px solid' }}>
          <Outlet />
        </div>
    </>
}
const About = (props) => {
  return <div>
    About Compontent
  </div>;
}

const Setting = (props) => {
  return <div>
    Setting Compontent
  </div>;
}

const List = (props) => {
  return <div>
    List Compontent
  </div>;
}
const navColor=(isActive) =>{
    return {color:isActive?'red':''}
}
```

主要实现了给当前激活的链接设置一个样式，支持**style**和**className**这两种属性;

### 读取URL参数

`./App.js`

```js
import {Route,Routes,NavLink,Outlet,useParams} from 'react-router-dom'
export default function App(){
    <Routes>
      <Route path='/' element={<Home />}>
         <Route path='list' element={<List />}>
           <Route path=':id' element={<Item />}></Route>
         </Route>
      </Route>
    <Routes>
}
const Home=(props)=>{
    return <>
        <div>
      <NavLink
        style={({ isActive }) => navColor(isActive)}
        to='/list'
      >
        List Link
      </NavLink>
    </div>
    <div style={{ padding: '20px', margin: '10px', borderTop: '1px solid' }}>
      <Outlet />
    </div>
    </>
}
const Item=(props)=>{
    // 从 URL 获取参数： :id
    const params = useParams();
    return <h2>Item:{params.id}</h2>
}
const List=(props)=>{
    const list=[
        {
            name:'赵云',
            no:100
        },
        {
            name:'马超',
            no:101
        }
    ]
    return <div>
    {
        list.map((item)=>{
            return (
                <NavLink style={({isActive}) => navColor(isActive)} to={`/llist/${item.no}`} key={item.no}>
                </NavLink>
            )
        })
    }
    <div className='content'>
    {/*指定子路由 /list/? 的渲染位置*/}
    </div>
    </div>
}
```

## 与 V5的区别

1. `Routes>`替代 `<Switch>`
    写法上的比较:

    ```js
    // v5 写法
    // 引入 react-router
    import { Route, Switch } from 'react-router-dom';
    function App() {
      return (
          <Switch>
            {/* 路由配置 */}
          </Switch>
      );
    }
    // v6 写法
    import { Route, Routes } from 'react-router-dom';
    function App() {
      return (
          // Routes 替换 Switch
        <Routes> 
          {/* 路由配置 */}
        </Routes>
      );
    }
    
    ```

    v6 的优点：
    v6提供了强大的`Routes`组件来代替Switch组价，Routes不再按顺序匹配路径，而是采用了一种自动匹配最佳路径的方法；

2. `<Route>`不再支持子组件，改为element属性，并且不再需要exact 属性了
    写法上的比较：

    ```js
    // v5 写法
    // 引入 react-router
    import { Route, Switch } from 'react-router-dom';
    function App() {
      return (
          <Switch>
            <Route exact path='/home'>
              <Home />
            </Route>
          </Switch>
      );
    }
    // v6 写法
    import { Route, Routes } from 'react-router-dom';
    function App() {
      return (
        <Routes>
          <Route path='/home' element={<Home /> } />
        </Routes>
      );
    } 
    ```

    v6的优点：
    (1) v6提供的element属性，可以使开发者更方便的注入想要的props；
    (2) v6的path是相对的
    (3) 可以按照所需要的任何顺序放置路由，路由器将自动检测当前URL的最佳路由

3. 移除了`<NavLink>`的activeClassName属性
    v5的写法：

    ```js
    <NavLink to="home" activeClassName="highlight">
      Home
    </NavLink>
    ```

    v6写法:

    ```js
    import { NavLink } from 'react-router-dom';
    function App(){
        return (
            <>
            {/*className 写法*/}
            <NaLink
                className={({isActive})=>{
                    return isActive ? "highlight" : ""
                }}
                to="home">Home</NavLlink>
                
                {/*style 写法*/}
                <NavLink
                    to="about"
                    style={({isActive})=>{
                        return {
                            color:isActive?"red":""
                        }
                    }}
            </>
        )
    }
    ```

4. 移除`<Redirect>`，，改为使用`<Navigate>`
    写法上的对比:
    v5的写法

    ```js
    // to---新位置
      <Redirect to={{ pathname: '/login', state: { from: location }}}
    ```

    v6的写法

    ```js
    import {Navigate,Route,ROutes} from 'react-router-dom'
    function App(){
        return (
          <Routes>
            <Route path='/' element={<Navigate replace to='/home' /> } />
          </Routes>
        )
    }
    ```

5. `<Link to=''>`支持相对位置

    ```js
    // 配置路由
    <Route path="app">
        <Route path="home">
             <Route path="list" />
        </Route>
    </Route>
    
    // 当前 URL 是 /app/home
    <Link to="list">               => <a href="/app/home/list>
    <Link to="../list">            => <a href="/app/list>
    <Link to="../../list">         => <a href="/list>
    <Link to="../../../list">      => <a href="/list>
    ```

6. 新增`<Ooutlet>`
    关于`<Outlet>`，参考本文的**嵌套路由**节点；此组件是一个占位符，告诉React Router 嵌套的内容应该放到哪里；通过`<Outlet>`可以将所有的路由(嵌套的子路由)配置合并在一起，可进行路由的统一管理，增加了代码可维护性。

7. 使用`useNavigate`实现编程式导航，从而代替`useHistory`

   ```js
   // v6 写法
   import {useNavigate} from 'react-router-dom'
   function App(){
       const navigate = useNavigate()
       const handleClick=()=>{
           navigate('/home'); // push
           // 重定向
           // navigae('home',{replace:true})
       }
       return (
        <div>
          <button onClick={handleClick}>返回首页</button>
        </div>
      ); 
   }
   ```

   主要写法变更：
   * history.push("/") => navigate("/")
   * history.replace("/) => navigate("/",{replace:true})
   * history.goBack() => navigate(-1)
   * history.goForward => navigate(1)
   * history.go(2) => navigate(2)

8. 一系列的Hooks

    | Hooks名        | 作用                               | 说明                              |
    | -------------- | ---------------------------------- | --------------------------------- |
    | useParams      | 返回当前参数                       | 根据路径读取参数                  |
    | useNavigate    | 返回当前路由                       | 代替原有V5中的history、withRouter |
    | useOutlet      | 返回根据路由生成的element          |                                   |
    | useLocation    | 返回当前的location对象             |                                   |
    | useRoutes      | 同Routes组件一样，只不过在js中使用 |                                   |
    | useSearchParam | 用来匹配URL中 ? 后面的搜索参数     |                                   |

### 项目注意

(1)  反向代理
[官网地址](https://create-react-app.dev/docs/proxying-api-requests-in-development/)
**下载安装**

```ssh
npm install http-proxy-middleware --save
```

**使用**

```js
const {createProxyMiddleware} = require('http-proxy-middleware')
module.exports=function(app){
    app.use(
    '/api',
    createProxyMiddleware({
        target:'http://localhost:5000',
        changOrigin:true
    })
    )
}
```

(2)css module
[官网地址](https://facebook.github.io/create-react-app/docs/adding-a-css-modules-stylesheet)
**适用**

```js
全局
:global(.active){
    ....
}
局部样式
import style from './css/Film.module.css'
<div className={style.film}></div>
```

# Flux与Redux

Flux是一种架构思想，专门解决软件的结构问题。它跟MVC架构是同一类东西，但是更加简单和清晰。Flux存在多种实现(至少15种)
> <https://github.com/voronianski/flux-comparison>

Facebook Flux是用来构建客户端Web应用的应用架构。它利用**单向数据流**的方式来组合React中的视图组件。它更像一个模式而不是一个正式的框架，开发者不需要太多的新代码就可以快速的上手Flux。
![](https://i0.hdslb.com/bfs/album/3f5e1659ee832c8c3bfebc80c45df204f90c6fee.png)
Redux最主要是用作应用状态的管理。简言之，Redux用一个单独的常量状态数(state对象)保存着一整个应用的状态，这个对象不能被直接改变。当一些数据变化，一个新的对象就会被创建(使用action和reducer),这样就可以进行数据追踪，实现时光旅行。

1. redux介绍及设计和使用的三大原则
    * state以单一对象存储在store对象中
    * state只读(每次都返回新的对象)
    * 使用纯函数reducer执行state更新
2. redux工作流
    ![](https://i0.hdslb.com/bfs/album/f05aac1f5831f3eebfe5bd7e51977ed45458472a.png)
3. 与react绑定后使用redux实现案例

    ```js
    import {createStore} from 'redux'
    const reducer =(state="defalutState,data={})=>{
        let {type,paload} = data
        switch(type){
            case 'changetitle':
                return payload
            defalut:
                return state
        }
    }
    const store = createStore(reducer)
    export store;
    ```

    ```js
    store.dispatch({
        type:'changetitle',
        payload:res.data.data.film.name
    })
    componentDidMount(){
        store.subscribe(()=>{
            this.setState({
                title:store.getStore()
            })
        })
    }
    ```

    ```js
    import {SHOW_TABBAR,HIDE_TABBAR} from '../../store/type'
    ```

4. redux原理解析
store是通过createStore创建出来的，所以它的结构

```js
export const createStore=function(reducer,initalState){
    ...
    return {
        ...
    }
}
```

dispatch,用于action的分发，改变store里面的state(currentState)=reducer(currentState,action),并在内部遍历subscribe注册的监听器
subscribe，注册listener，store里面state发生改变后，执行该listener
getState，取store里面的state

```js
function createStore(reducer){
    var list=[];
    var state=reducer();
    function subscribe(callback){
        list.push(callback)
    }
    function dispatch(data){
        state=reducer(state,data)
        for(var i in liat){
            list[i]()
        }
    }
    function getState(){
        return state;
    }
    return {
        subscribe,
        dispatch,
        getState
    }
    
}
```

5. reducer扩展
    如果不同的action所处理的数学之间没有联系，我们可以把Reducer函数拆分。不同的函数负责处理不同的属性，最终把它们合并成一个大的Reducer即可。

```js
import {combineReducers} from 'redux'
const reducer = combineReducers({
    a:functionA,
    b:functionB,
    c:functionC
})
访问：
(state)=>{
    return {
        Iekakistate:state.a(不同的命名空间)
    }
}
```

6. redux中间件
 在redux里，action仅仅是携带了数据的普遍js对象。action creator返回的值是这个action类型的对象。然后通过store。dispatch()分发。同步的情况下一些都很完美，但是reducer无法处理异步的情况。
那么我们就需要action和reducer中间架起一座桥梁来处理异步，这就是middleware.
① 中间件的由来与原理、机制
    
    ```js
    
    ```

 export default functionthunkMiddleware({dispatch,getState}){ returnnext=>action=>
      typeofaction==='function'?
       action(dispatch,getState):
       next(action);
    }
    ```
 这段代码的意思是，中间件这个桥梁接受到的参数action，如果不是function则和过去一样直接执行next方法(下一步处理)，相当于中间件没有做任何事。如果action是function，则先执行action，action的处理结束之后，再在action的内部调用dispatch。
②  常用异步中间件：
a. redux-thunk (store.dispatch参数可以是一个function)

```js
importthunkfrom'redux-thunk';
import{applyMiddleware}from"redux";
const store=createStore(fetchReducer,applyMiddleware(thunk));
{ //进行异步请求
     return(dispatch,store)=>{
     ...
     }
 }
```

b.  redux-promise (store.dispatch参数可以是一个promise对象

```js
import promiseMiddleware from 'redux-promise';
conststore=createStore(fetchReducer,applyMiddleware(thunk,promiseMiddleware));
const getComingSoon=()=>{
 //进行异步请求
 return axios.get(`****`).then(res=>{ 
     return{
       type:"cominglist",
       info:res.data.data
     }
}
   
```

7. Redux DevTools Extension

> <https://github.com/zalmoxisus/redux-devtools-extension>

```js
import {createStore, compose} from 'redux'
import reducer from'./reducer'
const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;
const store = createStore(reducer,/*preloadedState,*/composeEnhancers())
exportdefaultstore
```

# react-redux

1. 介绍

> <https://github.com/reactjs/react-redux>

2. 容器组件与UI组件
(1) UI组件
    * 只负责UI的呈现，不带有任何的业务逻辑
    * 没有状态（即不使用this.state这个变量)
    * 所有的数据都由参数(this.props)提供
    * 不使用任何Redux的API
(2) 容器组件
    * 负责管理数据和业务逻辑，不负责UI的呈现
    * 带有内部状态
    * 使用Redux的API
3. Provider与connect
(1) React-Redux 提供Provider组件，可以让容器组件拿到state。

```js
import React from 'react'
import ReactDOM from 'react-dom'
import {Provider} from 'react-redux'
import store from './store'
import App from './App'
const rootElement = document.getElementId('root')
ReactDDOm.render(
<Provider store={store}>
<App />
</Provider>,
rootElement
)
```

(2) React-Redux 提供action方法，用于UI组件生成容器组件，connect的意思，就是将这两种组件连起来

```js
import {connect} from 'react-redux'
import {increment,decrement,reset} from './actionCreators' //constCounter=...
const mapStateToProps=(state/*,ownProps*/)=>{  
    return{
      counter:state.counter
     }
 }
 const mapDispatchToProps ={increment,decrement,reset}
 export default connect(
 mapStateToProps,
 mapDispatchToProps
)(Counter)
```

4. HOC与context通信在react-redux底层中的应用
(1) connect是HOC，高阶组件
(2) Provider组件，可以让容器组件拿到state，使用context
5. 高阶组件构建与应用
HOC不仅仅是一个方法，确切说应该是一个组件工厂，获取低阶组件，生成高阶组件
(1) 代码复用，代码模块化
(2) 增删改props
(3) 渲染劫持

```js
// Child.js
// 高阶函数
​```js
function Control(wrappedComponent){
 return classMyControl extends React.Component{  
 render(){
       if(!this.props.data){
            return <div>loading...</div>
           }
       }
       return <wrapperComponent {...props} />
       }
   }
   exportdefaultControl(MyComponent);//高阶组件
```

```js
//Parent.js
import MyControlComponent from "./Child"
<MyControlComponent data={this.state.value}/>
//在父级传入data是null的时候，这一块儿就只会显示loading...,
//不会显示组件的具体内容，如果data不为null,就显示真实组件信息。
```

6. Redux持久化

```js
import {persistStore,persistReducer} from 'redux-persist';
import storage from 'redux-persist/lib/storage';
import autoMergeLevel2 from 'redux-persist/lib/stateReconciler/autoMergeLevel2';
const persistConfig={
  key:'kerwin',
  storage:storage,
  //localStorage:importstoragefrom'redux-persist/lib/storage'
  //sessionStorage:importstorageSessionfrom'redux-persist/lib/storage/session'  
  stateReconciler:autoMergeLevel2
  //控制在本地存储中，新老状态怎么合并，覆盖？或者合并？
};
//改造reducer
const myPersistReducer = persistReducer(persistConfig,reducer)
//改造store
export constpersistor = persistStore(store)
//改造根组件
import {persistor} from'./Store'
import {PersistGate} from'redux-persist/lib/integration/react';
<PersistGateloading={null}persistor={persistor}>     
...
</PersistGate>
```

