# 创建一个react项目
1.进行局部安装
```ssh
 npx create-react-app my-app-bli
 cd my-app-bli
 npm start
```
生成目录：
├──README.md             使用方法的文档
├──node_modules          所有的依赖安装的目录
├──package-lock.json     锁定安装时的包的版本号,保证团队的依赖能保证一致。
├──package.json         
├──public                静态公共目录
└──src                   开发用的源代码目录

出现如下信息，表示安装成功:
```ssh 
PS F:\学习更多\githubLearn\HTML5-Web\react\practices> npx create-react-app my-app-bli
Need to install the following packages:
  create-react-app
Ok to proceed? (y)
npm WARN deprecated tar@2.2.2: This version of tar is no longer supported, and will not receive security updates. Please upgrade asap.

Creating a new React app in F:\学习更多\githubLearn\HTML5-Web\react\practices\my-app-bli.

Installing packages. This might take a couple of minutes.
Installing react, react-dom, and react-scripts with cra-template...


added 1393 packages in 3m

Installing template dependencies using npm...
npm WARN deprecated source-map-resolve@0.6.0: See https://github.com/lydell/source-map-resolve#deprecated

added 52 packages in 10s
Removing template package using npm...


removed 1 package in 4s

Success! Created my-app-bli at F:\学习更多\githubLearn\HTML5-Web\react\practices\my-app-bli
Inside that directory, you can run several commands:

  npm start
    Starts the development server.

  npm run build
    Bundles the app into static files for production.

  npm test
    Starts the test runner.

  npm run eject
    Removes this tool and copies build dependencies, configuration files
    and scripts into the app directory. If you do this, you can’t go back!

We suggest that you begin by typing:

  cd my-app-bli
  npm start

Happy hacking!

```
2. 删除`src`下的文件，重新新建一个`index.js`文件

```js 
// 从 react 的包当中引入了 React。只要你要写 React.js 组件就必须引入React, 因为react里有 一种语法叫JSX，稍后会讲到JSX，要写JSX，就必须引入
React import React from 'react' 
// ReactDOM 可以帮助我们把 React 组件渲染到页面上去，没有其它的作用了。它是从 react-dom 中 引入的，而不是从 react 引入。 
import ReactDOM from 'react-dom' 
// ReactDOM里有一个render方法，功能就是把组件渲染并且构造 DOM 树，然后插入到页面上某个特定的 元素上 
ReactDOM.render( 
  // 这里就比较奇怪了，它并不是一个字符串，看起来像是纯 HTML 代码写在 JavaScript 代码里面。语 法错误吗？这并不是合法的 JavaScript 代码, “在 JavaScript 写的标签的”语法叫 JSX- JavaScript XML。
   <h1>欢迎进入React的世界</h1>, 
   // 渲染到哪里 
   document.getElementById('root') 
)

```
# JSX语法和组件
## 体验JSX语法
```js
import React from 'react';
import ReactDOM from 'react-dom';

//写法一：
ReactDOM.render(
  <div>
    <h1>1111</h1>
    <ul>
      <li>111</li>
      <li>111</li>
      <li>111</li>
    </ul>
  </div>,
  document.getElementById('root')
)
// 写法二:与写法一等效
ReactDOM.render(
React.createElement('div',{id:'app',className:'bbb'},'内容'),
  document.getElementById('root')
)

```
## class组件
* ES6写法
  ./scr/inde.js
  ```js
  import React from 'react';
  import ReactDOM from 'react-dom';
  import './01-base/01-class' // 引入自动加载 

  ReactDOM.render(
      React.createElement('div',{id:'app',className:'bbb'},'内容'),
      document.getElementById('root')
  )

  ```
  ./src/0-base/01-class
  ```js
  // ES6写法
  class Test{
    constructor(){
      this.a = 1
    }
    testa(){
      console.log("testa")
    } 
  }
  class ChildTest extends Test{
    testb(){
      console.log("testb")
    }
  }
  // var obj = new Test()
  // obj.testa() // 执行方法 输出testa
  // console.log(obj.a) // 打印属性  1

  var obj = new ChildTest()
  obj.testa() // 执行方法 输出 testa
  console.log(obj.a) // 输出 1

  ```
* ES7 写法
./src/index.js
```js 
import React from 'react';
import ReactDOM from 'react-dom';
import App from './01-base/01-class'
ReactDOM.render(
    <App />,
    document.getElementById('root')
)

```
  ./src/0-base/01-class
```js
// ES7 
// import React from 'react';
// class App extends React.Component{
//   render(){
//     return (
//       <div>1111</div>
//     )
//   }
// } 

import React, { Component } from 'react'
class App extends Component{
render(){
  // renturn () 用括号括起来，表示式回车下的属于一部分的内容
  return (
      <div>
        <h1>1111</h1>
        <ul>
          <li>111</li>
          <li>111</li>
          <li>111</li>
        </ul>
      </div>
  )
}
} 
export default App

```
* 复用组件(推荐)
组件 必须大写开头，否则会报错
为了让代码编写更规范，我们可以下载 插件 `ES7+ React/Redux/React-Native/JS snippets`
./src/index.js
```js
import React from 'react';
import ReactDOM from 'react-dom';
import App from './01-base/01-class'
ReactDOM.render(
    <App />,
    document.getElementById('root')
)
```
  ./src/0-base/01-class
  ```js 
import React, { Component } from 'react'
export default class App extends Component {
  render() {
    return (
      <div>01-class</div>
    )
  }
}

  ```
## 函数组件
16.8之前  无状态组件
16.8   react hooks 
./src/index/j
```js
import React from 'react';
import ReactDOM from 'react-dom';
import App from './01-base/02-fun'
ReactDOM.render(
    <App />,
    document.getElementById('root')
)
```
./src/01-base/02-fun.js
```js
function App(){
  return (
    <div>function Component</div>
  )
}

export default App

```
## 组件嵌套
./src/index.js
```js
import React from 'react';
import ReactDOM from 'react-dom';
import App from './01-base/03-Nesting.js'
ReactDOM.render(
    <App />,
    document.getElementById('root')
)
```
./src/01-base/03-Nesting.js
```js
import React, { Component } from 'react'
class Child extends Component{
  render(){
    return (
      <div>Child Component</div>
    )
  }
}
class Navbar extends Component {
  render(){
    return (
    <div>
      Navbar
      <Child></Child>
    </div>
    )
  }
}
function Swiper(){
  return <div>Swiper</div>
}
// const Tabbar =()=><div>Tabbar</div>
const Tabbar =()=>{
  return <div>Tabbar</div>
}

export default class App extends Component {
  render() {
    return (
      <div>
        {/* 想要在 Navbar 里嵌套子组件， 需要 在Navbar组件放入一个子组件Child，在子组件里写内容 ，而不是在放在<Navbar>标签中*/}
        <Navbar></Navbar>
        <Swiper></Swiper>
        <Tabbar></Tabbar>
      </div>
    )
  }
}

```
## 组件样式
./src/index.js
```js
import React from 'react';
import ReactDOM from 'react-dom';
import './01-base/css/04.css' // y引入外部css样式
import App from './01-base/04-style.js'
ReactDOM.render(
    <App />,
    document.getElementById('root')
)

```
./src/01-base/04-style.js
```js
import React, { Component } from 'react'

export default class App extends Component {
  render() {
    var myname = 'Iekaki'
    // 此样式写仅为演示，项目中不推荐这样使用
    var obj ={
      background:'red', // 需要加入引号
      backgroundColor:'green', // 单一属性需要 写成驼峰写法
      fontSize:'10px'
    }
    return (
      <div>
        {/* 模板语法 */}
        {10+20}
        {/* 变量 */}
        {10+20}- {myname}
        {/* 三目运算 ，加减乘除 ，字符串*/}
        {10>20?'aaa':'bbb'}
        {/* style={} 需要放入一个对象 */}
        <div style={{background:"red"}}>111111</div>
        <div style={obj}>111111</div>
        {/* 属性需要驼峰写法 css样式 需要引入外部css文件*/}
        {/* 另外 class ,for是react的关键字 不可以使用 
        <div class='active'>111111</div>
        <label for='username'>用户名:</label>
        */}
        <div className='active'>111111</div>
        <div id='active'>111111</div>
        <label htmlFor=''>用户名:</label>
        <label htmlFor='username'>用户名:</label>
          <input type="text" id='username'></input>
        
      </div>
    )
  }
}
```
## 事件对象
###  使用
./src/index.js
```js
import React from 'react';
import ReactDOM from 'react-dom';
import App from './01-base/05-event.js'
ReactDOM.render(
    <App />,
    document.getElementById('root')
)

```
./src/01-base/05-event.js
```js
import React, { Component } from 'react'

export default class App extends Component {
  render() {
    return (
      <div>
        05-event
        <input />
        {/* on + 事件类型（注意要写驼峰） */}
        <button onMouseEnter={()=>{
          console.log('onMouseEnter')
        }}>onMouseEnter</button>
        <button onMouseOver={()=>{
          console.log('onMouseEnter')
        }}>onMouseOver</button>

        {/* 无过多逻辑 推荐用法 */}
        <button onClick={()=>{
          console.log('click1')
        }}>add1</button>

        {/* 可以定义在外边  不要加() 画蛇添足 <button onClick={this.handleClick()}></button>*/}
        <button onClick={this.handleClick2}>dd2</button>
        <button onClick={this.handleClick3}>add3</button> 
        {/*组合  逻辑过多 推荐写法*/}
        <button onClick={()=>{
          this.handleClick4()
        }}>add4</button>     
        </div>
    )
  }
  handleClick2(){
    console.log('click2')
  }
  handleClick3=()=>{
    console.log('click3')
  }
  handleClick4=()=>{
    console.log('click3')
  }
}


```
### 事件绑定
./src/01-base/06-eventbind.js
```js
import React, { Component } from 'react'
export default class App extends Component {
  a = 1000
  render() {
    return (
      <div>
        05-event
        <input />
        {/* on + 事件类型（注意要写驼峰） */}
        <button onClick={()=>{
          console.log('click1',this.a)
        }}>add1</button>
        <button onClick={this.handleClick2}>add3</button> 
        <button onClick={this.handleClick.bind(this)}>add-bind不推荐这种写法</button> 
        <button onClick={this.handleClick3}>add3</button> 
        <button onClick={this.handleClick3evt}>SyntheticBaseEvent</button> 
        <button onClick={()=>{
          this.handleClick4()
        }}>add4</button>     
        </div>
    )
  } 
  handleClick2(){
    console.log('click2',this) // click2  undefined
  }
  handleClick(){
    console.log('click2',this.a) // click2  100  绑定 App 的实例
  }
  
  handleClick3=()=>{
    console.log('click3',this.a) // click3  100 箭头函数箭头函数`的this指向指向上下文，所以永久能拿到当前组件实例的this指向
  }
  handleClick3evt=(evt)=>{
    console.log('handleClick3evt',evt,evt.target) // click3  SyntheticBaseEvent  <button>SyntheticBaseEvent</button>
  }
  handleClick4=()=>{
    console.log('click4',this.a) // click4 100 箭头函数，还可以传参
  }
}
/**
 * React 并不会真正的绑定到每一个具体 <> 的元素上，而是采用事件代理的模式:
*/

  // this 的指向 复习
  var obj1 ={
    name:'obj1',
    getName(){
      console.log('obj1')
    }
  }
  var obj2 ={
    name:'obj1',
    getName(){
      console.log('obj1')
    }
  }
  obj1.getName() // obj1
  obj2.getName() // obj2
  obj1.getName.call(obj2) // obj2
  obj1.getName.apply(obj2) // obj2
  obj1.getName.bind(obj2) // 没有打印内容
  obj1.getName.bind(obj2)()  // 自动执行 obj2


```
## Ref 应用
./src/index.js
```js
import React from 'react';
import ReactDOM from 'react-dom';
import App from './01-base/07-ref.js'
ReactDOM.render(
  // 严格模式
  <React.StrictMode>
    <App />
  </React.StrictMode>,
    // <App />,
    document.getElementById('root')
)

```
### 以前的写法
./src/01-base/07-ref.js
```js
import React, { Component } from 'react'
export default class App extends Component {
  render() {
    return (
      <div>
        Ref的应用
        <input ref="mytext"></input>
        <button onClick={()=>{
          // 获取Dom/组件 this.refs.xxx 即将被弃用 严格模式下会报错
          console.log('click',this.refs.mytext,this.refs.mytext.value) // click <input /> 输入的内容
        }}></button>
      </div>
    )
  }
}

```
### 现在的写法
```js
import React, { Component } from 'react'
export default class App extends Component {
  myref= React.createRef() // 返回一个ref对象
  render() {
    return (
      <div>
        Ref的应用
        <input ref={this.myref}></input>
        <button onClick={()=>{
          // 使用 React.createRef()
          console.log("click",this.myref,this.myref.value) // this.myref----{current:input,[[Proptotype]]: Object} 
        }}>点击</button>
        <button onClick={this.handleClick}></button>
        <button onClick={this.handleClick2.bind(this)}></button>
        <button onClick={this.handleClick3}></button>
      </div>
    )
  }
  handleClick(){
    // 这里的 this指向 div 不是 App
    console.log("handleClick ",this.myref,this.myref.value) // undefined
  }
  handleClick2(){
    // 这里的 this指向 App
    console.log("handleClick2 ",this.myref,this.myref.value) // this.myref----{current:input,[[Proptotype]]: Object} 
  }
  handleClick3=()=>{
    // 这里的 this指向 App
    console.log("handleClick3 ",this.myref,this.myref.value) // this.myref----{current:input,[[Proptotype]]: Object} 
  }
}

```

# 组件的数据挂载方式
## state状态
./src/01-base/08-state.js
```js
import React, { Component } from 'react'

export default class App extends Component {
  // state={
  //   mytext:"收藏",
  //   myShow:true
  // }
  // 还可以这样定义state
  constructor(){
    super()
    this.state={
      mytext:"收藏",
      myShow:true,
      myname:'Iekika'
    }
  }
  render() {
    return (
      <div>
        App
        <button onClick={()=>{
          // this.state.mytext = "取消" // 不可以直接修改 state状态
          // 需要这样修改 间接修改
          this.setState({
            mytext:"取消收藏",
            // setState 可以合并修改的状态
            myname:'kkkkk'
          })
        }}>{this.state.mytext}</button>
        {/* 项目中更推荐这种写法 */}
        <button onClick={()=>{
          this.setState({
            myShow:!this.state.myShow
          })
          // 需要对接接口时
          if(this.state.myShow){
            console.log('收藏的逻辑')
          }else{
            console.log("取消收藏的逻辑")
          }
        }}>{this.state.mytext ? "收藏": "取消收藏"}</button>
      </div>
    )
  }
}

```
## 渲染数据
./src/01-base/09-render.js
```js
# 创建一个react项目
1.进行局部安装
​```ssh
 npx create-react-app my-app-bli
 cd my-app-bli
 npm start
```
生成目录：
├──README.md             使用方法的文档
├──node_modules          所有的依赖安装的目录
├──package-lock.json     锁定安装时的包的版本号,保证团队的依赖能保证一致。
├──package.json         
├──public                静态公共目录
└──src                   开发用的源代码目录

出现如下信息，表示安装成功:
```ssh 
PS F:\学习更多\githubLearn\HTML5-Web\react\practices> npx create-react-app my-app-bli
Need to install the following packages:
  create-react-app
Ok to proceed? (y)
npm WARN deprecated tar@2.2.2: This version of tar is no longer supported, and will not receive security updates. Please upgrade asap.

Creating a new React app in F:\学习更多\githubLearn\HTML5-Web\react\practices\my-app-bli.

Installing packages. This might take a couple of minutes.
Installing react, react-dom, and react-scripts with cra-template...


added 1393 packages in 3m

Installing template dependencies using npm...
npm WARN deprecated source-map-resolve@0.6.0: See https://github.com/lydell/source-map-resolve#deprecated

added 52 packages in 10s
Removing template package using npm...


removed 1 package in 4s

Success! Created my-app-bli at F:\学习更多\githubLearn\HTML5-Web\react\practices\my-app-bli
Inside that directory, you can run several commands:

  npm start
    Starts the development server.

  npm run build
    Bundles the app into static files for production.

  npm test
    Starts the test runner.

  npm run eject
    Removes this tool and copies build dependencies, configuration files
    and scripts into the app directory. If you do this, you can’t go back!

We suggest that you begin by typing:

  cd my-app-bli
  npm start

Happy hacking!

```
2. 删除`src`下的文件，重新新建一个`index.js`文件

```js 
// 从 react 的包当中引入了 React。只要你要写 React.js 组件就必须引入React, 因为react里有 一种语法叫JSX，稍后会讲到JSX，要写JSX，就必须引入
React import React from 'react' 
// ReactDOM 可以帮助我们把 React 组件渲染到页面上去，没有其它的作用了。它是从 react-dom 中 引入的，而不是从 react 引入。 
import ReactDOM from 'react-dom' 
// ReactDOM里有一个render方法，功能就是把组件渲染并且构造 DOM 树，然后插入到页面上某个特定的 元素上 
ReactDOM.render( 
  // 这里就比较奇怪了，它并不是一个字符串，看起来像是纯 HTML 代码写在 JavaScript 代码里面。语 法错误吗？这并不是合法的 JavaScript 代码, “在 JavaScript 写的标签的”语法叫 JSX- JavaScript XML。
   <h1>欢迎进入React的世界</h1>, 
   // 渲染到哪里 
   document.getElementById('root') 
)

```
# JSX语法和组件
## 体验JSX语法
```js
import React from 'react';
import ReactDOM from 'react-dom';

//写法一：
ReactDOM.render(
  <div>
    <h1>1111</h1>
    <ul>
      <li>111</li>
      <li>111</li>
      <li>111</li>
    </ul>
  </div>,
  document.getElementById('root')
)
// 写法二:与写法一等效
ReactDOM.render(
React.createElement('div',{id:'app',className:'bbb'},'内容'),
  document.getElementById('root')
)

```
## class组件
* ES6写法
  ./scr/inde.js
  ```js
  import React from 'react';
  import ReactDOM from 'react-dom';
  import './01-base/01-class' // 引入自动加载 

  ReactDOM.render(
      React.createElement('div',{id:'app',className:'bbb'},'内容'),
      document.getElementById('root')
  )

  ```
  ./src/0-base/01-class
  ```js
  // ES6写法
  class Test{
    constructor(){
      this.a = 1
    }
    testa(){
      console.log("testa")
    } 
  }
  class ChildTest extends Test{
    testb(){
      console.log("testb")
    }
  }
  // var obj = new Test()
  // obj.testa() // 执行方法 输出testa
  // console.log(obj.a) // 打印属性  1

  var obj = new ChildTest()
  obj.testa() // 执行方法 输出 testa
  console.log(obj.a) // 输出 1

  ```
* ES7 写法
./src/index.js
```js 
import React from 'react';
import ReactDOM from 'react-dom';
import App from './01-base/01-class'
ReactDOM.render(
    <App />,
    document.getElementById('root')
)

```
  ./src/0-base/01-class
```js
// ES7 
// import React from 'react';
// class App extends React.Component{
//   render(){
//     return (
//       <div>1111</div>
//     )
//   }
// } 

import React, { Component } from 'react'
class App extends Component{
render(){
  // renturn () 用括号括起来，表示式回车下的属于一部分的内容
  return (
      <div>
        <h1>1111</h1>
        <ul>
          <li>111</li>
          <li>111</li>
          <li>111</li>
        </ul>
      </div>
  )
}
} 
export default App

```
* 复用组件(推荐)
组件 必须大写开头，否则会报错
为了让代码编写更规范，我们可以下载 插件 `ES7+ React/Redux/React-Native/JS snippets`
./src/index.js
```js
import React from 'react';
import ReactDOM from 'react-dom';
import App from './01-base/01-class'
ReactDOM.render(
    <App />,
    document.getElementById('root')
)
```
  ./src/0-base/01-class
  ```js 
import React, { Component } from 'react'
export default class App extends Component {
  render() {
    return (
      <div>01-class</div>
    )
  }
}

  ```
## 函数组件
16.8之前  无状态组件
16.8   react hooks 
./src/index/j
```js
import React from 'react';
import ReactDOM from 'react-dom';
import App from './01-base/02-fun'
ReactDOM.render(
    <App />,
    document.getElementById('root')
)
```
./src/01-base/02-fun.js
```js
function App(){
  return (
    <div>function Component</div>
  )
}

export default App

```
## 组件嵌套
./src/index.js
```js
import React from 'react';
import ReactDOM from 'react-dom';
import App from './01-base/03-Nesting.js'
ReactDOM.render(
    <App />,
    document.getElementById('root')
)
```
./src/01-base/03-Nesting.js
```js
import React, { Component } from 'react'
class Child extends Component{
  render(){
    return (
      <div>Child Component</div>
    )
  }
}
class Navbar extends Component {
  render(){
    return (
    <div>
      Navbar
      <Child></Child>
    </div>
    )
  }
}
function Swiper(){
  return <div>Swiper</div>
}
// const Tabbar =()=><div>Tabbar</div>
const Tabbar =()=>{
  return <div>Tabbar</div>
}

export default class App extends Component {
  render() {
    return (
      <div>
        {/* 想要在 Navbar 里嵌套子组件， 需要 在Navbar组件放入一个子组件Child，在子组件里写内容 ，而不是在放在<Navbar>标签中*/}
        <Navbar></Navbar>
        <Swiper></Swiper>
        <Tabbar></Tabbar>
      </div>
    )
  }
}

```
## 组件样式
./src/index.js
```js
import React from 'react';
import ReactDOM from 'react-dom';
import './01-base/css/04.css' // y引入外部css样式
import App from './01-base/04-style.js'
ReactDOM.render(
    <App />,
    document.getElementById('root')
)

```
./src/01-base/04-style.js
```js
import React, { Component } from 'react'

export default class App extends Component {
  render() {
    var myname = 'Iekaki'
    // 此样式写仅为演示，项目中不推荐这样使用
    var obj ={
      background:'red', // 需要加入引号
      backgroundColor:'green', // 单一属性需要 写成驼峰写法
      fontSize:'10px'
    }
    return (
      <div>
        {/* 模板语法 */}
        {10+20}
        {/* 变量 */}
        {10+20}- {myname}
        {/* 三目运算 ，加减乘除 ，字符串*/}
        {10>20?'aaa':'bbb'}
        {/* style={} 需要放入一个对象 */}
        <div style={{background:"red"}}>111111</div>
        <div style={obj}>111111</div>
        {/* 属性需要驼峰写法 css样式 需要引入外部css文件*/}
        {/* 另外 class ,for是react的关键字 不可以使用 
        <div class='active'>111111</div>
        <label for='username'>用户名:</label>
        */}
        <div className='active'>111111</div>
        <div id='active'>111111</div>
        <label htmlFor=''>用户名:</label>
        <label htmlFor='username'>用户名:</label>
          <input type="text" id='username'></input>
        
      </div>
    )
  }
}
```
## 事件对象
###  使用
./src/index.js
```js
import React from 'react';
import ReactDOM from 'react-dom';
import App from './01-base/05-event.js'
ReactDOM.render(
    <App />,
    document.getElementById('root')
)

```
./src/01-base/05-event.js
```js
import React, { Component } from 'react'

export default class App extends Component {
  render() {
    return (
      <div>
        05-event
        <input />
        {/* on + 事件类型（注意要写驼峰） */}
        <button onMouseEnter={()=>{
          console.log('onMouseEnter')
        }}>onMouseEnter</button>
        <button onMouseOver={()=>{
          console.log('onMouseEnter')
        }}>onMouseOver</button>

        {/* 无过多逻辑 推荐用法 */}
        <button onClick={()=>{
          console.log('click1')
        }}>add1</button>

        {/* 可以定义在外边  不要加() 画蛇添足 <button onClick={this.handleClick()}></button>*/}
        <button onClick={this.handleClick2}>dd2</button>
        <button onClick={this.handleClick3}>add3</button> 
        {/*组合  逻辑过多 推荐写法*/}
        <button onClick={()=>{
          this.handleClick4()
        }}>add4</button>     
        </div>
    )
  }
  handleClick2(){
    console.log('click2')
  }
  handleClick3=()=>{
    console.log('click3')
  }
  handleClick4=()=>{
    console.log('click3')
  }
}


```
### 事件绑定
./src/01-base/06-eventbind.js
```js
import React, { Component } from 'react'
export default class App extends Component {
  a = 1000
  render() {
    return (
      <div>
        05-event
        <input />
        {/* on + 事件类型（注意要写驼峰） */}
        <button onClick={()=>{
          console.log('click1',this.a)
        }}>add1</button>
        <button onClick={this.handleClick2}>add3</button> 
        <button onClick={this.handleClick.bind(this)}>add-bind不推荐这种写法</button> 
        <button onClick={this.handleClick3}>add3</button> 
        <button onClick={this.handleClick3evt}>SyntheticBaseEvent</button> 
        <button onClick={()=>{
          this.handleClick4()
        }}>add4</button>     
        </div>
    )
  } 
  handleClick2(){
    console.log('click2',this) // click2  undefined
  }
  handleClick(){
    console.log('click2',this.a) // click2  100  绑定 App 的实例
  }
  
  handleClick3=()=>{
    console.log('click3',this.a) // click3  100 箭头函数箭头函数`的this指向指向上下文，所以永久能拿到当前组件实例的this指向
  }
  handleClick3evt=(evt)=>{
    console.log('handleClick3evt',evt,evt.target) // click3  SyntheticBaseEvent  <button>SyntheticBaseEvent</button>
  }
  handleClick4=()=>{
    console.log('click4',this.a) // click4 100 箭头函数，还可以传参
  }
}
/**
 * React 并不会真正的绑定到每一个具体 <> 的元素上，而是采用事件代理的模式:
*/

  // this 的指向 复习
  var obj1 ={
    name:'obj1',
    getName(){
      console.log('obj1')
    }
  }
  var obj2 ={
    name:'obj1',
    getName(){
      console.log('obj1')
    }
  }
  obj1.getName() // obj1
  obj2.getName() // obj2
  obj1.getName.call(obj2) // obj2
  obj1.getName.apply(obj2) // obj2
  obj1.getName.bind(obj2) // 没有打印内容
  obj1.getName.bind(obj2)()  // 自动执行 obj2


```
## Ref 应用
./src/index.js
```js
import React from 'react';
import ReactDOM from 'react-dom';
import App from './01-base/07-ref.js'
ReactDOM.render(
  // 严格模式
  <React.StrictMode>
    <App />
  </React.StrictMode>,
    // <App />,
    document.getElementById('root')
)

```
### 以前的写法
./src/01-base/07-ref.js
```js
import React, { Component } from 'react'
export default class App extends Component {
  render() {
    return (
      <div>
        Ref的应用
        <input ref="mytext"></input>
        <button onClick={()=>{
          // 获取Dom/组件 this.refs.xxx 即将被弃用 严格模式下会报错
          console.log('click',this.refs.mytext,this.refs.mytext.value) // click <input /> 输入的内容
        }}></button>
      </div>
    )
  }
}

```
### 现在的写法
```js
import React, { Component } from 'react'
export default class App extends Component {
  myref= React.createRef() // 返回一个ref对象
  render() {
    return (
      <div>
        Ref的应用
        <input ref={this.myref}></input>
        <button onClick={()=>{
          // 使用 React.createRef()
          console.log("click",this.myref,this.myref.value) // this.myref----{current:input,[[Proptotype]]: Object} 
        }}>点击</button>
        <button onClick={this.handleClick}></button>
        <button onClick={this.handleClick2.bind(this)}></button>
        <button onClick={this.handleClick3}></button>
      </div>
    )
  }
  handleClick(){
    // 这里的 this指向 div 不是 App
    console.log("handleClick ",this.myref,this.myref.value) // undefined
  }
  handleClick2(){
    // 这里的 this指向 App
    console.log("handleClick2 ",this.myref,this.myref.value) // this.myref----{current:input,[[Proptotype]]: Object} 
  }
  handleClick3=()=>{
    // 这里的 this指向 App
    console.log("handleClick3 ",this.myref,this.myref.value) // this.myref----{current:input,[[Proptotype]]: Object} 
  }
}

```

# 组件的数据挂载方式
## state状态
./src/01-base/08-state.js
```js
import React, { Component } from 'react'

export default class App extends Component {
  // state={
  //   mytext:"收藏",
  //   myShow:true
  // }
  // 还可以这样定义state
  constructor(){
    super()
    this.state={
      mytext:"收藏",
      myShow:true,
      myname:'Iekika'
    }
  }
  render() {
    return (
      <div>
        App
        <button onClick={()=>{
          // this.state.mytext = "取消" // 不可以直接修改 state状态
          // 需要这样修改 间接修改
          this.setState({
            mytext:"取消收藏",
            // setState 可以合并修改的状态
            myname:'kkkkk'
          })
        }}>{this.state.mytext}</button>
        {/* 项目中更推荐这种写法 */}
        <button onClick={()=>{
          this.setState({
            myShow:!this.state.myShow
          })
          // 需要对接接口时
          if(this.state.myShow){
            console.log('收藏的逻辑')
          }else{
            console.log("取消收藏的逻辑")
          }
        }}>{this.state.mytext ? "收藏": "取消收藏"}</button>
      </div>
    )
  }
}

```
## 渲染数据
./src/01-base/09-render.js
```js
import React, { Component } from 'react'

export default class App extends Component {
  state={
    // list:["1111","2222","3333"]
    listdata:{
      {id:1,text:"1111"},
      {id:2,text:"2222"},
      {id:3,text:"3333"}
    }
  }
  render() {
    // const newlist = this.state.list.map(item=><li>{item}</li>)
    // 确保节点有一个唯一的标识key，列表的复用和重排，事件的错误绑定，设置key，提高性能
     const newlist = this.state.list.map(item=><li key={item.id}>{item.text}</li>)
    return (
      <div>
        App渲染列表
        <ul>
          {/* 
          这种写法是错误的
          {
            this.state.list.map(item=>
              <li>{item}</li>
              )
          } */}
          {newlist}
          
        </ul>
      </div>
    )
  }
}

```

## todolist 案例
./src/10-todolist.js
```js
import React, { Component } from 'react'
import './css/04.css'
export default class App extends Component {
  constructor(){
    super()
      this.state = {
      listdata:[
        {id:1,text:"1111"},
        {id:2,text:"2222"},
        {id:3,text:"3333"}
      ] 
      }
  }
  myref= React.createRef() // 返回一个ref对象
  render() {
    // const list = this.state.listdata.map(item=><li key={item.id}>{item.text}</li>)
    return (
      <div>
        TodoList案例
        <hr></hr>
        <input ref={this.myref}></input>
        <button onClick={this.handleClick}>add</button> 
        {/* <ul> {list}</ul> */}
        <ul>
          {
            this.state.listdata.map((item,index)=>
              <li key={item.id}>
                {/*item.text*/}
                {/*富文本展示 dangerouslySetInnerHTML={{__html:xxxx}}*/} 
                <span dangerouslySetInnerHTML={{__html:item.text}}></span>
                {/* <button onClick={this.handleDelClick.bind(this,index)}>del</button> */}
                <button onClick={()=>this.handleDelClick(index)}>del</button>
              </li>
              )
          }
        </ul>
        {/* {this.state.listdata.length===0?<div>暂无数据</div>:null}  */}
        {/* {this.state.listdata.length===0&&<div>暂无数据</div>}  */}
        <div className={this.state.listdata.length===0?'':'hidden'}>暂无数据</div>
      </div>
    )
  }
  handleClick=()=>{
    console.log("click",this.myref.current.value)
    // 不要直接修改 this.state的状态
    // this.state.datalist.push(this.myref.current.value)
    // this.setState({
    //   listdata:this.state.datalist
    // })
    // 我们应该这样写：
    const newlist = [...this.state.listdata] // 深拷贝一份数据
    // newlist.push(this.myref.current.value)
    newlist.push({
      id:Math.random()*100000000,
      text:this.myref.current.value
    })
    this.setState({
      listdata:newlist
    })
    console.log("listdata",this.state.listdata)
    // 清空输入框
    this.myref.current.value = ""
  }
  handleDelClick(index){
    console.log('del')
    // 不要直接修改状态，会造成不可预期的后果
    const list = this.state.listdata.concat()
    list.splice(index,1)
    this.setState({
      listdata:list
    })

  }
}

```
## 卖座网案例 
### 卖座网底部导航active案例
./src/01-base/11-Action.js
```js
import React, { Component } from 'react'
import './css/11.css'
import Film from './maizuocomponent/Film'
import Cinema from './maizuocomponent/Cinema'
import Center from './maizuocomponent/Center'

export default class App extends Component {
  state={
    list:[
      {
        id:1,
        text:"电影",
      },
      {
        id:2,
        text:"影院"
      },
      {
        id:3,
        text:"我的"
      }
    ],
    current:0
  }
  which(){
    switch(this.state.current){
      case 0:
        return <Film></Film>
      case 1:
        return <Cinema></Cinema>
      case 2:
        return <Center></Center>
      default:
        return null
    }
  }
  render() {
    return (
      <div>
        {/* 显示内容 */}
        {/* 
          {
              this.state.current===0 && <Film></Film>
          }
          {
              this.state.current===1 && <Cinema></Cinema>
          }
          {
              this.state.current===2 && <Center></Center>
          } 
        */}
        {
          // 我们可以使用表达式-支持函数表达式
          this.which()
        }
        <ul>
        {
          this.state.list.map((item,index)=>
          <li key={item.id} className={this.state.current===index?'active':''} onClick={()=>this.handleClick(index)}>{item.text}</li>
          )
        }          
        </ul>
      </div>
    )
  }
  handleClick(index){
    this.setState({current:index})
  }
}

```

### 卖座网列表&&input输入过滤
./src/maizuocomponent/cinema.jsx
```js
import React, { Component } from 'react'
import axios from 'axios'
export default class Cinema extends Component {
  constructor(){
    super()
    this.state={
      cinemaList:[],
      backcinemaList:[]
    }

    // 1. 生命周期里请求数据--后面了解
    // 2.axios 第三方库 ，专门用于数据请求
    // axios.get("https://m.maizuo.com/gateway?cityId=440100&ticketFlag=1&k=6427887").then(res=>{
    //   console.log(res)
    // }).catch(err=>{
    //   console.log(err)
    // })

    axios({
      url:"https://m.maizuo.com/gateway?cityId=440100&ticketFlag=1&k=4475775",
      method:"get",
      headers:{
        'X-Client-Info': '{"a":"3000","ch":"1002","v":"5.2.0","e":"16556881321698500651778049","bc":"440100"}',
        'X-Host': 'mall.film-ticket.cinema.list'
      }
    }).then(res=>{
      // 有两条数据主要是开了严格模式
      console.log(res.data)
      this.setState({
        // 关掉严格模式
        cinemaList:res.data.data.cinemas,
        backcinemaList:res.data.data.cinemas
      })
    })
  
  }
  render() {
    return (
      <div>
        {/* Cinema列表 */}
        <input onInput={this.handleInput}></input>
          {
            this.state.cinemaList.map(item=>
            <dl key={item.cinemaId}>
              <dt>{item.name}</dt>
              <dd>{item.address}</dd>
            </dl>
              )
            }

      </div>
    )
  }
  handleInput=(evt)=>{
    console.log('input',evt.target.value)
    const newlist = this.state.backcinemaList.filter(item=>item.name.toUpperCase().includes(evt.target.value.toUpperCase()) || item.address.toUpperCase().includes(evt.target.value))
    console.log(newlist)
    // cinemaList 每次都会被覆盖 所以需要哪一个备份数据操作
    this.setState({
      cinemaList:newlist
    })

  }
}
/**
 * filter
 */
// var arr =["aaa","abc","bcc"]
// var newArr = arr.filter(item=>item.includes("a"))
// console.log(newArr)
```
![](https://i0.hdslb.com/bfs/album/a079e6d5bae5d0dc6d2d1f84df325871f9e99c2c.png)
![](https://i0.hdslb.com/bfs/album/203b47213f0a2ce4f3f13c4f0c918188890a7258.png)

## setState 异步
./src/12-setState-Syncawait.js
```js
import React, { Component } from 'react'

export default class Syncawait extends Component {
  state={
    count:0
  }
  render() {
    return (
      <div>
        {this.state.count}
        <button onClick={this.handleAdd1}>add1</button>
        <button onClick={this.handleAdd2}>ad2</button>
      </div>
    )
  }
  handleAdd1=()=>{
    // 1.
    // this.setState({
    //   count:this.state.count + 1
    // })
    //   count:this.state.count + 1
    // this.setState({
    //   count:this.state.count+1
    // })
    //  count:this.state.count + 1
    // this.setState({
    //   count:this.state.count+1
    // })
    //   count:this.state.count + 1

    // 3.
    this.setState({
      count:this.state.count + 1
    },()=>{
      console.log(this.state.count)
    })
    this.setState({
      count:this.state.count+1
    },()=>{
      console.log(this.state.count)
    })
    this.setState({
      count:this.state.count+1
    },()=>{
      console.log(this.state.count)
      // 状态和真实dom已经更新完了
    })
  }
  handleAdd2=()=>{
    // 2
    setTimeout(()=>{
      this.setState({
        count:this.state.count + 1
      })
      this.setState({
        count:this.state.count+1
      })
      this.setState({
        count:this.state.count+1
      })
    })
  }
}
/**
 * setState 会合并状态
 * 1.setState 处在同步的逻辑中，异步更新状态，更新真实dom
 * 2.setState 处在异步的逻辑中，同步更新状态，更新真实dom
 * 
 * 3.setState 接收第二个参数，第二个参数是回调函数，状态和dm更新完后就会触发
 */

```
## 属性(props)
### 介绍
props 是正常是外部传入的，组件内部也可以通过一些方式来初始化的设置，属性不能被组件自己更
改，但是你可以通过父组件主动重新渲染的方式来传入新的 props

属性是描述性质、特点的，组件自己不能随意更改。

之前的组件代码里面有 props 的简单使用，总的来说，在使用一个组件的时候，可以把参数放在标签的
属性当中，所有的属性都会作为组件 props 对象的键值。通过箭头函数创建的组件，需要通过函数的
参数来接收 props : 

(1) 在组件上通过key=value 写属性,通过this.props获取属性,这样组件的可复用性提高了。 

(2) 注意在传参数时候，如果写成isShow="true" 那么这是一个字符串 如果写成isShow={true} 这个 是布尔值 

(3) {...对象} 展开赋值 

(4) 默认属性值
./src/15-props.js
```js
import React, { Component } from 'react'
import Navbar from './src/Navbar'
export default class props extends Component {
  render() {
    return (
      <div>
        <div>
          <h2>首页</h2>
          {/* 
          leftShow 传入 props的是一个字符串
          <Navbar title="首页" leftShow="false"></Navbar> 
          */}
          <Navbar title="首页" leftShow={false}></Navbar>
        </div>
        <div>
          <h2>列表</h2>
          <Navbar title="列表"></Navbar>
        </div>
        <div>
          <h2>购物车</h2>
          <Navbar title="购物车"></Navbar>
        </div>
        
      </div>
    )
  }
}


```
### 类/函数 组件Props
./src/16.propsFun.js
```js
import React, { Component } from 'react'
import Navbar from './src/Navbar'
import Sidebar from './src/Sidebar'
export default class propsFun extends Component {
  render() {
    return (
      <div>
        <div>
          {/* 类组件 */}
          <Navbar title="购物车"></Navbar>
          {/* 函数组件 */}
          <Sidebar bg="green" position="left"></Sidebar>
        </div>
      </div>
    )
  }
}


```
./src/Navbar/index.js
```js
// 函数式组件 rfc
import React from 'react'

export default function Sidebar(props) {
  // console.log(this)
  let { bg,position} = props
  var obj1 = {
    left:0
  }
  var obj2={
    right:0
  }
  var obj={
    background:bg,
    width:'200px',
    position:'fixed'
  }
  // 可以利用合并
  var styleobj = position === 'left' ? {...obj,...obj1} : {...obj,...obj2} 
  return (
    // <div style={{background:bg,width:'200px',position:position}}>
    <div style={styleobj}>
      <ul>
        <li>11111</li>
        <li>11111</li>
        <li>11111</li>
        <li>11111</li>
        <li>11111</li>
        <li>11111</li>
        <li>11111</li>
        <li>11111</li>
      </ul>
    </div>
  )
}


```
### 属性 VS state
相似点：都是纯js对象，都会触发render更新，都具有确定性（状态/属性相同，结果相同）
不同点：

1. 属性能从父组件获取，状态不能

2. 属性可以由父组件修改，状态不能

3. 属性能在内部设置默认值，状态也可以，设置方式不一样

4. 属性不在组件内部修改，状态要在组件内部修改

5. 属性能设置子组件初始值，状态不可以

6. 属性可以修改子组件的值，状态不可以

state 的主要作用是用于组件保存、控制、修改自己的可变状态。 
state 在组件内部初始化，可以被组件自身修改，而外部不能访问也不能修改。你可以认为 state 是一个局部的、只能被组件自身控制的数据源。 state 中状态可以通过 this.setState 方法进行更新， setState 会导致组件的重新渲染。

props 的主要作用是让使用该组件的父组件可以传入参数来配置该组件。它是外部传进来的配置参数，组件内部无法控制也无法修改。除非外部组件主动传入新的 props ，否则组件的 props 永远保持不变。

没有 state 的组件叫无状态组件（stateless component），设置了 state 的叫做有状态组件（stateful component）。因为状态会带来管理的复杂性，我们尽量多地写无状态组件，尽量少地写有状态的组件。这样会降低代码维护的难度，也会在一定程度上增强组件的可复用性。

```js
import React, { Component } from 'react'

class Child extends Component{
    render(){
        return <div>
            child-{this.props.text}

            <button onClick={()=>{
                this.props.text = "333333333333333333"
            }}>click-子</button>
        </div>
    }
}

export default class App extends Component {
    state = {
        text:"111111111"
    }
    render() {
        return (
            <div>
                <button onClick={()=>{
                    this.setState({
                        text:"2222222"
                    })
                }}>click-父</button>
                <Child text = {this.state.text}/>
            </div>
        )
    }
}



```

# 表单中的受控组件与非受控组件
## 1.非受控组件
React 要编写一个非受控组件，可以使用ref来从DOM节点中获取表单数据,就是非受控组件。
例如，下面的代码使用非受控组件接受一个表单的值：
```js
class NameForm extends React.Component { 
  constructor(props) { 
    super(props); this.handleSubmit = this.handleSubmit.bind(this); 
    this.input = React.createRef(); 
  }
handleSubmit(event) { 
  alert('A name was submitted: ' + this.input.current.value); 
  event.preventDefault(); }
  render() { 
    return ( 
      <form onSubmit={this.handleSubmit}> 
        <label> Name: 
          <input type="text" ref={this.input} /> 
        </label> 
        <input type="submit" value="Submit" /> 
      </form> ); 
    } 
    }

```
因为非受控组件将真实数据储存在 DOM 节点中，所以在使用非受控组件时，有时候反而更容易同时集
成 React 和非 React 代码。如果你不介意代码美观性，并且希望快速编写代码，使用非受控组件往往可
以减少你的代码量。否则，你应该使用受控组件。
**默认值**
在 React 渲染生命周期时，表单元素上的 value 将会覆盖 DOM 节点中的值，在非受控组件中，你经
常希望 React 能赋予组件一个初始值，但是不去控制后续的更新。 在这种情况下, 你可以指定一个
defaultValue 属性，而不是 value 。
```js
render() {
  return (
    <form onSubmit={this.handleSubmit}> 
    <label> Name: 
      <input defaultValue="Bob" type="text" ref={this.input} /> 
    </label> 
    <input type="submit" value="Submit" /> 
    </form> 
  ); 
  }

```
同样， <input type="checkbox"> 和 <input type="radio"> 支持 defaultChecked ， <select> 和 <textarea> 支持 defaultValue 。
## 受控组件
```js
class NameForm extends React.Component {  
  constructor(props) {    
    super(props);    
    this.state= {value: ''};
    this.handleChange=this.handleChange.bind(this);    
    this.handleSubmit=this.handleSubmit.bind(this);  
  }
  handleChange(event) {    
    this.setState({value: event.target.value});  
  }
  handleSubmit(event) {    
    alert('提交的名字: '+this.state.value);    
    event.preventDefault();  
  }
  render() {    
    return (      
      <form onSubmit={this.handleSubmit}>        
      <label> 名字:      
         <input type="text"value={this.state.value} onChange={this.handleChange} />
      </label>  
       <input type="submit"value="提交"/> 
       </form>
          ); 
  }
}
```
由于在表单元素上设置了`value`属性，因此显示的值将始终为`this.state.value`,这使得React的state成为唯一的数据源。由于`handelchange`在每次按键是都会执行并更新React的state，因此显示的值将随着用户输入而更新。
对于受控组件来说，输入的值始终由React的state驱动，你也可以将value传递给其他UI元素，或者其他事件处理函数重置，但这意味着你需要编写更多的代码。

> 注意：另一种说法(广义范围的说法),React组件的数据渲染是否被调用者传递的props完全控制，控制则为受控组件，否则非受控组件。




# 组件的通信方式
## 父子组件通信方式
(1)传递数据(父传子)与传递方法(子传父)
(2)ref标记(父组件拿到子组件的引用，从而调用子组件的方法)
  在父组件中清除子组件的input输入框的value值。this.refs.from.reset()
## 非父子组件的通信方式
(1)状态提升(中间人模式)
   React中的状态提升概括来说，就是多个组件需要共享的状态提升到它们最近的父组件上，在父组件上改变这个状态然后通过props分发给子组件。
(2)发布订阅模式实现
(3)context状态数传参

   ```js
  //  a.先定义全局context对象
  import React from 'react'
  const GlobalContext = React.createContext()
  export default GlobalContext
   ```
   ```js
  //  b.根组件引入GlobalContext，并使用GlobalContText.Provider(生产者)
  // 重新包装根组件 class App()
  <GlobalContext.Provider
  value={{
    name:'Iekika',
    age:18,
    content:this.state.content,
    show:this.show.bind(this),
    hide:this.hide.bind(this)
  }}
  >
  </GlobalContext.Provider>

   ```
   ```js
  //  c.任意组件引入 GlobalContext 并调用context,使用GlobalConntext.Consumer(消费者)
  <GlobalContext>
  {
    context=>{
      this.myshow = = context.show // 可以在当前组件任意函数触发
      this.myhide = context.hide; // 可以在当前组件任意函数触发 
      return (
        <div>
        {context.name}-{context.age}-{context.context}
        </div>
      )
    }
  }
  </GlobalContext>

   ```
   注意： GlobalContext.Consumer 内必须是回调函数，通过context方法改变根组件状态
> context 优缺点:
> 优点:跨组件访问数组
> 缺点: react组件树种某个上级组件shouldComponentUpdate返回false，当context更新时，不会引起下级组件的更新。

## 代码案例：
----------
- 父子组件通信方式
  + 传递数据(父传子)与传递方法(子传父)
    ./scr/02-advanced/01-ChildPropsParent.js
    ```js
      import React, { Component } from 'react'

      class Navbar extends Component{
        render(){
          return <div style={{background:"red"}}>
            <button onClick={()=>{
              console.log("子通知符，让父的isShow 取反",this.props.event)
              this.props.event() // 调用父组件的函数
            }}>click</button>
            <span>navbar</span>
          </div>
        }
      }
      class Sidebar extends Component{
        render(){
            return <div style={{background:"yellow",width:"200px"}}> 
                <ul>
                    <li>11111</li>
                    <li>11111</li>
                    <li>11111</li>
                    <li>11111</li>
                    <li>11111</li>
                    <li>11111</li>
                </ul>
            </div>
        }
      }
      export default class App extends Component {
        state={
          isShow:false
        }
        handleEvent=()=>{
          this.setState({
            isShow:!this.state.isShow
          })
          console.log("父组件定义的event事件")
        }
        render() {
          return (
            <div>
              {/* <Navbar event={()=>{
                // this.setState({
                //   isShow:!this.state.isShow
                // })
                console.llog("父组件定义的event事件")
              }}></Navbar> */}
              <Navbar event={this.handleEvent} />
              {this.state.isShow && <Sidebar></Sidebar>}
            </div>
          )
        }
      }
      /**
      * 父传子 ： 属性
      * 子传父 ：回调函数callback
      */
    ```

  + ref 标记
    ./src/02-advanced/05-RefNameFrom.js
    ```js
          import React, { Component } from 'react'

        // 一个简单的Antd 的Filed组件原理
        class Filed extends Component{
          state={
            value:""
          }
          clear(){
            this.setState({
              value:""
            })
          }
          setVlaue(val){
            this.setState({
              value:val
            })
          }
          render(){
            return (
              // 受控组件
              <div style={{background:"yellow"}}>
                <lable>{this.props.label}</lable>
                <input type={this.props.type} onChange={(evt)=>{
                  this.setState({
                    value:evt.target.value
                  })
                }} value={this.state.value}/>
              </div>
            )
          }
        }
        export default class App extends Component {
          username = React.createRef()
          password = React.createRef() 
          render() {
            return (
              <div>
                <h1>登录页面</h1>
                <Filed label="用户名" type="text" ref={this.username}></Filed>
                <Filed label="密码" type="password" ref={this.password}></Filed>
                <button onClick={()=>{
                  console.log('拿到当前DOM/组件实例',this.username.current)
                    console.log(this.username.current.state.value,this.password.current.state.value)
                }}>登录</button>
                <button onClick={()=>{
                  this.username.current.clear()
                  this.password.current.clear()
                }}>取消保存</button>
              </div>
            )
          }
        }

    ```
- 非父子组件的通信方式
   + 状态提升(中间人模式)
      ![](https://i0.hdslb.com/bfs/album/a76ae98199981386be6233aab5e8fbcc49b47b37.png)
      ./src/02-advanced/06-intermediary.js

      ```js
      import React, { Component } from 'react'
      import axios from 'axios'
      import './css/maizuo.css'
      
      export default class App extends Component {
        constructor() {
          super()
          this.state = {
            filmList: [],
            info:''
          }
          axios.get(`test.json`).then(res => {
            console.log(res.data.data.films)
            this.setState({
              filmList: res.data.data.films
            })
          })
        }
        render () {
          return (
            <div>
              {
                this.state.filmList.map(item =>
                  <FilmItem key={item.filmId} {...item} onEvent={(value)=>{
                    console.log("父组件接收value",value)
                    this.setState({
                      info:value 
                    })
                  }}></FilmItem>
                )
              }
              <FilmDetail info={this.state.info}></FilmDetail>
            </div>
          )
        }
      }
      
      // 受控组件
      class FilmItem extends Component {
        render () {
          console.log('FilmList', this.props)
          const { name, poster,grade,synopsis } = this.props
          return <div className='filmitem' onClick={()=>{
            this.props.onEvent(synopsis) // 调用父组件并传入数据
          }}>
            <img src={poster} alt={name}></img>
            <h4>{name}</h4>
            <div>观众评分：{grade}</div>
          </div>
        }
      }
      
      class FilmDetail extends Component {
        render(){
          return <div className='filmdetail'>
            {this.props.info}
          </div>
        }
      }
      ```
   + 发布订阅模式实现
    ![](https://i0.hdslb.com/bfs/album/00b4c73b3861e952183a00dd66b06eedde1b1c65.png)
    ![](https://i0.hdslb.com/bfs/album/38b690096717d0c9a6fd97e436acb60bb620216e.png)
      ```js
        import React, { Component } from 'react'
        import axios from 'axios'
        import './css/maizuo.css'

        // 调度中心
        var bus ={
          list:[],
          //订阅
          subscribe(callback){
            this.list.push(callback)
          },
          // 发布
          publish(text){
            this.list.forEach(callback=>{
              callback && callback(text)
            })
          }
        }

        export default class App extends Component {
          constructor() {
            super()
            this.state = {
              filmList: []
            }
            axios.get(`test.json`).then(res => {
              console.log(res.data.data.films)
              this.setState({
                filmList: res.data.data.films
              })
            })
          }
          render () {
            return (
              <div>
                {
                  this.state.filmList.map(item =>
                    <FilmItem key={item.filmId} {...item} ></FilmItem>
                  )
                }
                <FilmDetail></FilmDetail>
              </div>
            )
          }
        }

        // 受控组件
        class FilmItem extends Component {
          render () {
            console.log('FilmList', this.props)
            const { name, poster,grade,synopsis } = this.props
            return <div className='filmitem' onClick={()=>{
              console.log(synopsis)
              bus.publish(synopsis)
            }}>
              <img src={poster} alt={name}></img>
              <h4>{name}</h4>
              <div>观众评分：{grade}</div>
            </div>
          }
        }

        class FilmDetail extends Component {
          constructor(){
            super()
            this.state={
              info:''
            }
            bus.subscribe((info)=>{
              console.log("我再filmDetail中定义",info)
              this.setState({
                info:info
              })
            })
          }
          render(){
            return <div className='filmdetail'>
              {this.state.info}
            </div>
          }
        }
      ```
   + context 
      ![](https://i0.hdslb.com/bfs/album/4d8b21f9cc949bc804ed9398cbe5eeb16216a945.png)
       ./src/02-advanced/09-context.js

       ```js
        import React, { Component } from 'react'
          import axios from 'axios'
          import './css/maizuo.css'
      
          const GlobalContext = React.createContext() // 创建context上下文对象
          export default class App extends Component {
            constructor() {
              super()
              this.state = {
                filmList: [],
                info:''
              }
              axios.get(`test.json`).then(res => {
                console.log(res.data.data.films)
                this.setState({
                  filmList: res.data.data.films
                })
              })
            }
            render () {
              return (
                // GlobalContext.Provider 供应商组件
                <GlobalContext.Provider value={
                  {
                    call:"打电话",
                    sms:"短信",
                    info:this.state.info,
                    changeInfo:(val)=>{
                      this.setState({
                        info:val
                      })
                    }
                  }
                }>
                  <div>
                    {
                      this.state.filmList.map(item =>
                        <FilmItem key={item.filmId} {...item} ></FilmItem>
                      )
                    }
                    <FilmDetail></FilmDetail>
                  </div>
                </GlobalContext.Provider>
              )
            }
          }
      
          // 受控组件
          class FilmItem extends Component {
            render () {
              console.log('FilmList', this.props)
              const { name, poster,grade,synopsis } = this.props
              return (  
                <GlobalContext.Consumer>
                  {
                    (value)=>{
                      console.log(value)
                      return <div className='filmitem' onClick={()=>{
                        console.log(synopsis)
                        value.changeInfo(synopsis)
                        }}>
                        <img src={poster} alt={name}></img>
                        <h4>{name}</h4>
                        <div>观众评分：{grade}</div>
                      </div>
                    }
                  }
              </GlobalContext.Consumer>
              )
            }
          }
      
          class FilmDetail extends Component {
            render(){
              return (
                <GlobalContext.Consumer>
                {
                  // (value)=>{
                  //    return <div className='filmdetail'>
                  //     {value.info}
                  //   </div>
                  // }
                  (value)=><div className='filmdetail'>
                    {value.info}
                  </div>
                  }
                </GlobalContext.Consumer>
              )
            }
          }
       ```

- 插槽
./src/02-advanced/10-slot.js
```js
import React, { Component } from 'react'

class Child extends Component{
    render(){
        return <div>
            child

            {/* 插槽 vue slot,具名插槽 */}

            {this.props.children[2]}
            {this.props.children[1]}
            {this.props.children[0]}
        </div>
    }
}

class Swiper extends Component{
    render(){
        return <div>
            {this.props.children}
        </div>
    }
}

export default class App extends Component {
    render() {
        return (
            <div>

                <Swiper>
                    <div>111111</div>
                    <div>222222</div>
                    <div>333333</div>
                </Swiper>
                <Swiper>
                    {/* <div><img/>111111</div>
                    <div><img/>222222</div>
                    <div><img/>333333</div> */}
                </Swiper>
                <Swiper>
                    {/* <img/>
                    <img/>
                    <img/> */}
                </Swiper>

                
                <Child>
                    <div>11111111</div>
                    <div>22222222</div>
                    <div>33333333</div>
                    {
                        // children
                    }
                </Child>
            </div>
        )
    }
}


/*
  1. 为了复用
  2. 一定程度减少父子通信。
*/

```

# React 生命周期 
## 1. 初始化阶段
* componentWillMount: render 之前最后一次修改状态的机会<font color=red>已废弃</font>   - 加上前缀才不会报错UNSAFE_componentWillMount
* render:只能访问`this.props`和`this.state`,不允许修改状态和DOM输出
* componentDidMount:成功render并渲染完成真实DOM之后触发，可以修改DOM
## 2.运行中阶段
* componentWillReceivePorps:父组件修改属性触发 <font color=red>已废弃</font>
* shouldComponentUpdate:返回false会阻止render调用
* componentWillUpdate:不能修改属性和状态
* render:只能访问this.props和this.state,不允许修改状态和DOM输出
* componentDidUpdate:可以修改DOM 

## 销毁阶段
* componentWillUnmount:在删除组件之前清理操作，比如计时器和事件监听器

## 老生命周期的问题
(1) componentWillMount ,在ssr中 这个方法将会被多次调用， 所以会重复触发多遍，同时在这里如果绑定事件，
将无法解绑，导致内存泄漏 ， 变得不够安全高效逐步废弃。

(2) componentWillReceiveProps 外部组件多次频繁更新传入多次不同的 props，会导致不必要的异步请求

(3) componetWillupdate, 更新前记录 DOM 状态, 可能会做一些处理，与componentDidUpdate相隔时间如果过长，会导致 状态不太信

## 新生命周期的替代
(1) getDerivedStateFromProps:第一次的初始化组件以及后续的更新过程中(包括自身状态更新以及父传子),返回一个对象作为新的state，返回null则说明不需要在这里更新state
> 初始化时候 可以替代 componentWillMount 
> 父传子的时候 可以替代 componentWillReceivedProps 
```js
// 老的生命周期
componentDidMount(){
  if(this.props.value !== undefined){
    this.setState({
      current:this.props.value
    })
  }
}
componentWillReceivePorps(nextProps){
  if(nextProps.value !== undefined){
    this.setState({
      current:nextProps.value
    })
  }
}
// 新的生命周期写法
static getDerivedStateFromProps(nextProps){
  if(nextProps.value !== undefined){
    return {
      current:nextProps.value
    }
  }
  return null
}

```
(2) getSnapshotBeforeUpdate 取代了componentWillUpdate，触发事件为update发生的时候，在render之后dom渲染之前返回一个值，作为**componentDidUpdate**的第三个参数。

```js
// 新的数据不断插入数据前面，导致我正在看的数据往下走，如何保持可视图依旧是我之前看到的数据呢?
getSnapshotBeforeUpdate(){
  return this.refs.wrapper.scrollHeight
}
componentDidUpdate(prevProps,prevState,preHeight){
  // if(preHeight===200)return ;
  this.refs.wrapper.scrollTop +=this.refs.wrapper.scrolHeight-preHeight
}
<div style={{height:"200px",overflow:"auto"}}} ref="wrapper"> <ul>......... </ul> </div>
```

** shouldComponentUpdate**优化性能的案例
```js
import React, { Component } from 'react'

class Box extends Component{
  // 加上优化性能
  shouldComponentUpdate(nextProps, nextState) {
    if(this.props.current === this.props.index || nextProps.current===nextProps.index){
      return true
    }
    return false // 返回false 阻止render调用
  }
  render(){
    // return <div style={{width:"100px",height:"100px",border:"1px solid gray",margin:"10px",float:"left"}}></div>
    return <div style={{width:"100px",height:"100px",border:this.props.current === this.props.index?"1px solid #64de64":"1px solid gray",margin:"10px",float:"left"}}></div>
  }
}
export default class App extends Component {
  state={
    list:["00","01","02","03","04","05","06","07","08","09"],
    current:0
  }
  render() {
    return (
      <div>
        <input type="number" onChange={(evt)=>{
          this.setState({
            current:Number(evt.target.value)
          })
        }} value={this.state.current}></input>
        <div style={{overflow:"hidden"}}>
          {
            this.state.list.map((item,index)=>
              <Box key={item} current={this.state.current} index={index}></Box>
              )
          }

        </div>
        <Box></Box>
      </div>
    )
  }
}

```
## react中性能优化的方案
1. shouldComponentUpdate
控制组件自身或子组件是否更新，尤其在子组件非常多的情况下，需要进行优化。
2. PureComponent
PureComponent会帮你 比较新props 跟 旧的props， 新的state和老的state（值相等,或者对象含有相同的属性、且属性值相等 ），决定shouldcomponentUpdate 返回true 或者false， 从而决定要不要呼叫 render function。
注意：
如果你的 state 或 props 『永远都会变』，那 PureComponent 并不会比较快，因为
 shallowEqual 也需要花时间。

# React Hooks 
## 使用hooks 理由
1. 高阶组件为了复用，导致代码层级复杂
2. 生命周期的复杂
3. 写成function组件，无状态组件 ，因为需要状态，又改成了class成本高
### useState(保存组件状态)
```js
const [state,setState] = useState(initialState)
```
### useEffect(处理副作用)和useLayoutEffect(同步执行副作用)
Function Component 不存在生命周期，所以不要把Class Component的生命周期概念搬过拉力试图对号入座。
```js
useEffect(()=>{
  // effect
  return ()=>{
    // cleanup
  }
},[依赖的状态;空数组,表示不依赖])
```
**不要对Dependencles撒谎，如果你明明使用了某个变量，却，没有申明在依赖中，你等于向React撒了谎，后果就是，当依赖的变量改变时，useEffect也不会再次执行，eslint会报错**
PreView页面改造成函数式组件，在路径上从id=1切换到id=2也会自动重新加载，比class组件方便
```js
let id=props.match.params.myid 
useEffect(()=>{
  axios.get(`/articles/${id}`).then(res=>{
    settitle(res.data.title)
    setcontent(res.data.content)
    setcategory(res.data.category)
  })
})
```
useEffect和useLayout有什么区别?
**简单来说就是调用时机不同， useLayoutEffect 和原来 componentDidMount & componentDidUpdate 一致，在react完成DOM更新马上同步调用的代码，会阻塞页面渲染。而 useEffect 是会在整个页面渲染完才会调用的代码**
官方建议优先使用 useEffect
> However, we recommend starting with useEffect first and only trying useLayoutEffect if that causes a problem.

在实际使用时如果想要避免**页面抖动**(在`useEffect`里修改DOM很有可能出现)的话，可以把需要操作DOM的代码放在`useLayoutEffect`里。在这里做点dom操作，这dom修改会和react做出的更改一起被一次性渲染到屏幕上，只有一次回流、重绘的代价。

### useCallback(记忆函数)
*防止因为组件重新渲染，导致方法被重新创建，气到缓存作用，只有第二个参数变化了，才重新声明一次*
```js
var handleClick = useCallback(()=>{
  console.log(name)
},[name])
<button onClick={()=>handleClick()}>click</button>

// 只有name改变后，这个函数才会重新声明一次。
// 如果传入空数组，那么就是第一次创建后就被缓存，如果name后期改变了，拿到的还是老的name。
// 如果不传入第二个参数，每一次都会重新声明一次，拿到的就是最新的name。
```
### useMemo 记忆组件
useCallback 的功能完全可以由useMemo所取代，如果你想要通过使用useMemo返回一个记忆函数也是完全的。
```js
useCallback(fn,input) is equivalent to useMemo(()=>fn, inputs)
```
唯一的的区别是:**useCallback不会执行第一个参数函数，而是将它返回给你，而是useMemo会执行第一个函数并且将函数执行结果返回给你。**所以在前面的例子汇总，可以返回handleClick来达到存储函数的目的。
所以useCallback常用记忆事件函数，生成记忆后的事件函数并传递给子组件使用。而useMemo更适合经过函数计算得到一个确定的值，比如记忆组件。

### useRef(保存引用值)
```js
const myswiper = useRef(null);
<Swiper ref={myswiper} />
```
### useReducer 和 useContext(减少组件层级)
```js
import React from 'react'
var GlobalContext = React.createContext()
// 注意此时的reducer 返回值是一个对象 {isShow:false,list:[]}
function App(){
    let [state,dispatch] = useReducer(reducer,{isShow:true,list:[]})
    return <GlobalContext.Provider value={{
                dispatch
            }}>
              <div>
              {
                  state.isShow?<div>我是选项卡</div>:null
              }
              {props.children}
              </div>
            </GlobalContext.Provider>
}

function Detail(){
    var [dispatch] = useContext(GlobalContext)
    useEffect(()=>{
        // 隐藏
        dispatch({
            type:"Show",
            payload:false
        })
        return ()=>{
            // 显示
            dispatch({
                type:"Show",
                payload:true
            })
        }
    },[])
    return <div>detail</div>
}
```
#### 自定义hooks
**当我们想在两个函数之间共享逻辑时，我们会把它提取到到三个函数中。**
必须以`use`开头吗？<font color=red>必须如此</font>。这个约定非常重要，不遵循的话，由于无法判断某个函数是否包含对其内部Hook的调用，React将无法自动检查你的Hook是否违反了Hook的规则。





