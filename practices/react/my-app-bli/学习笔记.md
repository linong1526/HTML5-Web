# 创建一个react项目

1.进行局部安装

```ssh
 npx create-react-app my-app-bli
 cd my-app-bli
 npm start
```

生成目录：

├──README.md  ---------------------使用方法的文档
├──node_modules  -------------------所有的依赖安装的目录
├──package-lock.json  --------------锁定安装时的包的版本号,保证团队的依赖能保证一致
├──package.json
├──public  ------------------------------静态公共目录
└──src  ----------------------------------开发用的源代码目录

出现如下信息，表示安装成功:

```powershell
PS F:\学习更多\githubLearn\HTML5-Web\react\practices> npx create-react-app my-app-bli
Need to install the following packages:
  create-react-app
Ok to proceed? (y)
npm WARN deprecated tar@2.2.2: This version of tar is no longer supported, and will not receive security updates. Please upgrade asap.

Creating a new React app in F:\学习更多\githubLearn\HTML5-Web\react\practices\my-app-bli.

Installing packages. This might take a couple of minutes.
Installing react, react-dom, and react-scripts with cra-template...


added 1393 packages in 3m

Installing template dependencies using npm...
npm WARN deprecated source-map-resolve@0.6.0: See https://github.com/lydell/source-map-resolve#deprecated

added 52 packages in 10s
Removing template package using npm...


removed 1 package in 4s

Success! Created my-app-bli at F:\学习更多\githubLearn\HTML5-Web\react\practices\my-app-bli
Inside that directory, you can run several commands:

  npm start
    Starts the development server.

  npm run build
    Bundles the app into static files for production.

  npm test
    Starts the test runner.

  npm run eject
    Removes this tool and copies build dependencies, configuration files
    and scripts into the app directory. If you do this, you can’t go back!

We suggest that you begin by typing:

  cd my-app-bli
  npm start

Happy hacking!

```

2. 删除`src`下的文件，重新新建一个`index.js`文件

```jsx
// 从 react 的包当中引入了 React。只要你要写 React.js 组件就必须引入React, 因为react里有 一种语法叫JSX，稍后会讲到JSX，要写JSX，就必须引入
React import React from 'react' 
// ReactDOM 可以帮助我们把 React 组件渲染到页面上去，没有其它的作用了。它是从 react-dom 中 引入的，而不是从 react 引入。 
import ReactDOM from 'react-dom' 
// ReactDOM里有一个render方法，功能就是把组件渲染并且构造 DOM 树，然后插入到页面上某个特定的 元素上 
ReactDOM.render( 
  // 这里就比较奇怪了，它并不是一个字符串，看起来像是纯 HTML 代码写在 JavaScript 代码里面。语 法错误吗？这并不是合法的 JavaScript 代码, “在 JavaScript 写的标签的”语法叫 JSX- JavaScript XML。
   <h1>欢迎进入React的世界</h1>, 
   // 渲染到哪里 
   document.getElementById('root') 
)

```

`2022年截止 react-routerdom@6`版本写法

```jsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import from './App.js'
import { BrowserRouter } from "react-router-dom";
const root = ReactDOM.createRoot(document.getElementById('root'));
// root.render(<App/>);
root.render(
  <BrowserRouter>
    <React.StrictMode>
      <App />
    </React.StrictMode>
  </BrowserRouter>

  )
```

# JSX语法和组件

## 体验JSX语法

```jsx
import React from 'react';
import ReactDOM from 'react-dom';

//写法一：
ReactDOM.render(
  <div>
    <h1>1111</h1>
    <ul>
      <li>111</li>
      <li>111</li>
      <li>111</li>
    </ul>
  </div>,
  document.getElementById('root')
)
// 写法二:与写法一等效
ReactDOM.render(
React.createElement('div',{id:'app',className:'bbb'},'内容'),
  document.getElementById('root')
)

```

## class组件

* ES6写法
  `./scr/inde.js`
  
    ```jsx
  import React from 'react';
  import ReactDOM from 'react-dom';
import './01-base/01-class' // 引入自动加载 
  
  ReactDOM.render(
      React.createElement('div',{id:'app',className:'bbb'},'内容'),
      document.getElementById('root')
  )
    ```
  `./src/0-base/01-class`
  
    ```jsx
  // ES6写法
  class Test{
    constructor(){
      this.a = 1
    }
    testa(){
      console.log("testa")
    } 
  }
  class ChildTest extends Test{
    testb(){
      console.log("testb")
    }
  }
  // var obj = new Test()
// obj.testa() // 执行方法 输出testa
  // console.log(obj.a) // 打印属性  1
  
  var obj = new ChildTest()
obj.testa() // 执行方法 输出 testa
  console.log(obj.a) // 输出 1
    ```
  
* ES7 写法
  `./src/index.js`
  
    ```jsx
    import React from 'react';
    import ReactDOM from 'react-dom';
    import App from './01-base/01-class'
    ReactDOM.render(
        <App />,
        document.getElementById('root')
  )
    ```
  `./src/0-base/01-class`

    ```jsx
  // ES7 
  // import React from 'react';
  // class App extends React.Component{
  //   render(){
  //     return (
  //       <div>1111</div>
  //     )
  //   }
  // } 

  import React, { Component } from 'react'
  class App extends Component{
      render(){
      // renturn () 用括号括起来，表示式回车下的属于一部分的内容
          return (
              <div>
                <h1>1111</h1>
                <ul>
                  <li>111</li>
                  <li>111</li>
                  <li>111</li>
                </ul>
              </div>
          )
      }
  } 
  export default App
    ```
  
* 复用组件(推荐)
组件 必须大写开头，否则会报错
为了让代码编写更规范，我们可以下载 插件 `ES7+ React/Redux/React-Native/JS snippets`
  `./src/index.js`

    ```jsx
    import React from 'react';
    import ReactDOM from 'react-dom';
    import App from './01-base/01-class'
    ReactDOM.render(
        <App />,
        document.getElementById('root')
    )
    ```

  `./src/0-base/01-class`

    ```jsx
    import React, { Component } from 'react'
    export default class App extends Component {
      render() {
        return (
          <div>01-class</div>
        )
      }
    }
    ```

## 函数组件

16.8之前  无状态组件
16.8   react hooks
  `./src/index/j`

```jsx
import React from 'react';
import ReactDOM from 'react-dom';
import App from './01-base/02-fun'
ReactDOM.render(
    <App />,
    document.getElementById('root')
)
```

  `./src/01-base/02-fun.js`

```jsx
function App(){
  return (
    <div>function Component</div>
  )
}

export default App
```

## 组件嵌套

  `./src/index.js`

```jsx
import React from 'react';
import ReactDOM from 'react-dom';
import App from './01-base/03-Nesting.js'
ReactDOM.render(
    <App />,
    document.getElementById('root')
)
```

  `./src/01-base/03-Nesting.js`

```jsx
import React, { Component } from 'react'
class Child extends Component{
  render(){
    return (
      <div>Child Component</div>
    )
  }
}
class Navbar extends Component {
  render(){
    return (
    <div>
      Navbar
      <Child></Child>
    </div>
    )
  }
}
function Swiper(){
  return <div>Swiper</div>
}
// const Tabbar =()=><div>Tabbar</div>
const Tabbar =()=>{
  return <div>Tabbar</div>
}

export default class App extends Component {
  render() {
    return (
      <div>
        {/* 想要在 Navbar 里嵌套子组件， 需要 在Navbar组件放入一个子组件Child，在子组件里写内容 ，而不是在放在<Navbar>标签中*/}
        <Navbar></Navbar>
        <Swiper></Swiper>
        <Tabbar></Tabbar>
      </div>
    )
  }
}

```

## 组件样式

  `./src/index.js`

```jsx
import React from 'react';
import ReactDOM from 'react-dom';
import './01-base/css/04.css' // y引入外部css样式
import App from './01-base/04-style.js'
ReactDOM.render(
    <App />,
    document.getElementById('root')
)

```

  `./src/01-base/04-style.js`

```jsx
import React, { Component } from 'react'

export default class App extends Component {
  render() {
    var myname = 'Iekaki'
    // 此样式写仅为演示，项目中不推荐这样使用
    var obj ={
      background:'red', // 需要加入引号
      backgroundColor:'green', // 单一属性需要 写成驼峰写法
      fontSize:'10px'
    }
    return (
      <div>
        {/* 模板语法 */}
        {10+20}
        {/* 变量 */}
        {10+20}- {myname}
        {/* 三目运算 ，加减乘除 ，字符串*/}
        {10>20?'aaa':'bbb'}
        {/* style={} 需要放入一个对象 */}
        <div style={{background:"red"}}>111111</div>
        <div style={obj}>111111</div>
        {/* 属性需要驼峰写法 css样式 需要引入外部css文件*/}
        {/* 另外 class ,for是react的关键字 不可以使用 
        <div class='active'>111111</div>
        <label for='username'>用户名:</label>
        */}
        <div className='active'>111111</div>
        <div id='active'>111111</div>
        <label htmlFor=''>用户名:</label>
        <label htmlFor='username'>用户名:</label>
          <input type="text" id='username'></input>
        
      </div>
    )
  }
}
```

## 事件对象

### 使用

  `./src/index.js`

```jsx
import React from 'react';
import ReactDOM from 'react-dom';
import App from './01-base/05-event.js'
ReactDOM.render(
    <App />,
    document.getElementById('root')
)

```

  `./src/01-base/05-event.js`

```jsx
import React, { Component } from 'react'

export default class App extends Component {
  render() {
    return (
      <div>
        05-event
        <input />
        {/* on + 事件类型（注意要写驼峰） */}
        <button onMouseEnter={()=>{
          console.log('onMouseEnter')
        }}>onMouseEnter</button>
        <button onMouseOver={()=>{
          console.log('onMouseEnter')
        }}>onMouseOver</button>

        {/* 无过多逻辑 推荐用法 */}
        <button onClick={()=>{
          console.log('click1')
        }}>add1</button>

        {/* 可以定义在外边  不要加() 画蛇添足 <button onClick={this.handleClick()}></button>*/}
        <button onClick={this.handleClick2}>dd2</button>
        <button onClick={this.handleClick3}>add3</button> 
        {/*组合  逻辑过多 推荐写法*/}
        <button onClick={()=>{
          this.handleClick4()
        }}>add4</button>     
        </div>
    )
  }
  handleClick2(){
    console.log('click2')
  }
  handleClick3=()=>{
    console.log('click3')
  }
  handleClick4=()=>{
    console.log('click3')
  }
}


```

### 事件绑定

./src/01-base/06-eventbind.js

```jsx
import React, { Component } from 'react'
export default class App extends Component {
  a = 1000
  render() {
    return (
      <div>
        05-event
        <input />
        {/* on + 事件类型（注意要写驼峰） */}
        <button onClick={()=>{
          console.log('click1',this.a)
        }}>add1</button>
        <button onClick={this.handleClick2}>add3</button> 
        <button onClick={this.handleClick.bind(this)}>add-bind不推荐这种写法</button> 
        <button onClick={this.handleClick3}>add3</button> 
        <button onClick={this.handleClick3evt}>SyntheticBaseEvent</button> 
        <button onClick={()=>{
          this.handleClick4()
        }}>add4</button>     
        </div>
    )
  } 
  handleClick2(){
    console.log('click2',this) // click2  undefined
  }
  handleClick(){
    console.log('click2',this.a) // click2  100  绑定 App 的实例
  }
  
  handleClick3=()=>{
    console.log('click3',this.a) // click3  100 箭头函数箭头函数`的this指向指向上下文，所以永久能拿到当前组件实例的this指向
  }
  handleClick3evt=(evt)=>{
    console.log('handleClick3evt',evt,evt.target) // click3  SyntheticBaseEvent  <button>SyntheticBaseEvent</button>
  }
  handleClick4=()=>{
    console.log('click4',this.a) // click4 100 箭头函数，还可以传参
  }
}
/**
 * React 并不会真正的绑定到每一个具体 <> 的元素上，而是采用事件代理的模式:
*/

  // this 的指向 复习
  var obj1 ={
    name:'obj1',
    getName(){
      console.log('obj1')
    }
  }
  var obj2 ={
    name:'obj1',
    getName(){
      console.log('obj1')
    }
  }
  obj1.getName() // obj1
  obj2.getName() // obj2
  obj1.getName.call(obj2) // obj2
  obj1.getName.apply(obj2) // obj2
  obj1.getName.bind(obj2) // 没有打印内容
  obj1.getName.bind(obj2)()  // 自动执行 obj2


```

## Ref 应用

  `./src/index.js`

```jsx
import React from 'react';
import ReactDOM from 'react-dom';
import App from './01-base/07-ref.js'
ReactDOM.render(
  // 严格模式
  <React.StrictMode>
    <App />
  </React.StrictMode>,
    // <App />,
    document.getElementById('root')
)

```

### 以前的写法

  `./src/01-base/07-ref.js`

```jsx
import React, { Component } from 'react'
export default class App extends Component {
  render() {
    return (
      <div>
        Ref的应用
        <input ref="mytext"></input>
        <button onClick={()=>{
          // 获取Dom/组件 this.refs.xxx 即将被弃用 严格模式下会报错
          console.log('click',this.refs.mytext,this.refs.mytext.value) // click <input /> 输入的内容
        }}></button>
      </div>
    )
  }
}

```

### 现在的写法

```jsx
import React, { Component } from 'react'
export default class App extends Component {
  myref= React.createRef() // 返回一个ref对象
  render() {
    return (
      <div>
        Ref的应用
        <input ref={this.myref}></input>
        <button onClick={()=>{
          // 使用 React.createRef()
          console.log("click",this.myref,this.myref.value) // this.myref----{current:input,[[Proptotype]]: Object} 
        }}>点击</button>
        <button onClick={this.handleClick}></button>
        <button onClick={this.handleClick2.bind(this)}></button>
        <button onClick={this.handleClick3}></button>
      </div>
    )
  }
  handleClick(){
    // 这里的 this指向 div 不是 App
    console.log("handleClick ",this.myref,this.myref.value) // undefined
  }
  handleClick2(){
    // 这里的 this指向 App
    console.log("handleClick2 ",this.myref,this.myref.value) // this.myref----{current:input,[[Proptotype]]: Object} 
  }
  handleClick3=()=>{
    // 这里的 this指向 App
    console.log("handleClick3 ",this.myref,this.myref.value) // this.myref----{current:input,[[Proptotype]]: Object} 
  }
}

```

# 组件的数据挂载方式

## state状态

  `./src/01-base/08-state.js`

```jsx
import React, { Component } from 'react'

export default class App extends Component {
  // state={
  //   mytext:"收藏",
  //   myShow:true
  // }
  // 还可以这样定义state
  constructor(){
    super()
    this.state={
      mytext:"收藏",
      myShow:true,
      myname:'Iekika'
    }
  }
  render() {
    return (
      <div>
        App
        <button onClick={()=>{
          // this.state.mytext = "取消" // 不可以直接修改 state状态
          // 需要这样修改 间接修改
          this.setState({
            mytext:"取消收藏",
            // setState 可以合并修改的状态
            myname:'kkkkk'
          })
        }}>{this.state.mytext}</button>
        {/* 项目中更推荐这种写法 */}
        <button onClick={()=>{
          this.setState({
            myShow:!this.state.myShow
          })
          // 需要对接接口时
          if(this.state.myShow){
            console.log('收藏的逻辑')
          }else{
            console.log("取消收藏的逻辑")
          }
        }}>{this.state.mytext ? "收藏": "取消收藏"}</button>
      </div>
    )
  }
}

```

## 渲染数据

  `./src/01-base/09-render.js`

```jsx
import React, { Component } from 'react'

export default class App extends Component {
  state={
    // list:["1111","2222","3333"]
    listdata:[
      {id:1,text:"1111"},
      {id:2,text:"2222"},
      {id:3,text:"3333"}
    ] 
  }
  render() {
    // const newlist = this.state.list.map(item=><li>{item}</li>)
    const newlist = this.state.list.map(item=><li key={item.id}>{item.text}</li>)
    return (
      <div>
        App渲染列表
        <ul>
          {/* 
          这种写法是错误的
          {
            this.state.list.map(item=>
              <li>{item}</li>
              )
          } */}
          {newlist}
          
        </ul>
      </div>
    )
  }
}

```

# 表单中的受控组件与非受控组件

## 1.非受控组件

React 要编写一个非受控组件，可以使用ref来从DOM节点中获取表单数据,就是非受控组件.

例如，下面的代码使用非受控组件接受一个表单的值：

```jsx
class NameForm extends React.Component { 
  constructor(props) { 
    super(props); this.handleSubmit = this.handleSubmit.bind(this); 
    this.input = React.createRef(); 
  }
handleSubmit(event) { 
  alert('A name was submitted: ' + this.input.current.value); 
  event.preventDefault(); }
  render() { 
    return ( 
      <form onSubmit={this.handleSubmit}> 
        <label> Name: 
          <input type="text" ref={this.input} /> 
        </label> 
        <input type="submit" value="Submit" /> 
      </form> ); 
    } 
    }

```

因为非受控组件将真实数据储存在 DOM 节点中，所以在使用非受控组件时，有时候反而更容易同时集成 React 和非 React 代码。如果你不介意代码美观性，并且希望快速编写代码，使用非受控组件往往可以减少你的代码量。否则，你应该使用受控组件。


**默认值**

在 React 渲染生命周期时，表单元素上的 value 将会覆盖 DOM 节点中的值，在非受控组件中，你经常希望 React 能赋予组件一个初始值，但是不去控制后续的更新。 在这种情况下, 你可以指定一个`defaultValue` 属性，而不是 `value` 。


```jsx
render() {
  return (
    <form onSubmit={this.handleSubmit}> 
    <label> Name: 
      <input defaultValue="Bob" type="text" ref={this.input} /> 
    </label> 
    <input type="submit" value="Submit" /> 
    </form> 
  ); 
  }

```


同样， `<input type="checkbox">` 和 `<input type="radio">` 支持 **`defaultChecked`** ， `<select>` 和 `<textarea>` 支持 **`defaultValue`** 。


## 受控组件

```jsx
class NameForm extends React.Component {  
  constructor(props) {    
    super(props);    
    this.state= {value: ''};
    this.handleChange=this.handleChange.bind(this);    
    this.handleSubmit=this.handleSubmit.bind(this);  
  }
  handleChange(event) {    
    this.setState({value: event.target.value});  
  }
  handleSubmit(event) {    
    alert('提交的名字: '+this.state.value);    
    event.preventDefault();  
  }
  render() {    
    return (      
      <form onSubmit={this.handleSubmit}>        
      <label> 名字:      
         <input type="text"value={this.state.value} onChange={this.handleChange} />
      </label>  
       <input type="submit"value="提交"/> 
       </form>
          ); 
  }
}
```


由于在表单元素上设置了`value`属性，因此显示的值将始终为`this.state.value`,这使得React的state成为唯一的数据源。由于`handelchange`在每次按键是都会执行并更新React的state，因此显示的值将随着用户输入而更新。


对于受控组件来说，输入的值始终由React的state驱动，你也可以将value传递给其他UI元素，或者其他事件处理函数重置，但这意味着你需要编写更多的代码。

> 注意：另一种说法(广义范围的说法),React组件的数据渲染是否被调用者传递的props完全控制，控制则为受控组件，否则非受控组件。

# 组件的通信方式


## 父子组件通信方式

(1) 传递数据(父传子)与传递方法(子传父)
(2) ref标记(父组件拿到子组件的引用，从而调用子组件的方法)
    在父组件中清除子组件的input输入框的value值。this.refs.from.reset()

## 非父子组件的通信方式

(1) 状态提升(中间人模式)
      React中的状态提升概括来说，就是多个组件需要共享的状态提升到它们最近的父组件上，在父组件上改变这个状态然后通过props分发给子组件。
(2) 发布订阅模式实现
(3) context状态数传参

```jsx
//  a.先定义全局context对象
import React from 'react'
const GlobalContext = React.createContext()
export default GlobalContext
```

```jsx
//  b.根组件引入GlobalContext，并使用GlobalContText.Provider(生产者)
// 重新包装根组件 class App()
<GlobalContext.Provider
    value={{
        name:'Iekika',
        age:18,
        content:this.state.content,
        show:this.show.bind(this),
        hide:this.hide.bind(this)
        }}
    >
</GlobalContext.Provider>

```

```jsx
    //  c.任意组件引入 GlobalContext 并调用context,使用GlobalConntext.Consumer(消费者)
<GlobalContext>
  {
    context=>{
      this.myshow = = context.show // 可以在当前组件任意函数触发
      this.myhide = context.hide; // 可以在当前组件任意函数触发 
      return (
        <div>
        {context.name}-{context.age}-{context.context}
        </div>
      )
    }
  }
</GlobalContext>
```


 注意： `GlobalContext.Consumer` 内必须是 **回调函数**，通过context方法改变根组件状态

> context 优缺点:
> 优点:跨组件访问数组
> 缺点: react组件树种某个上级组件shouldComponentUpdate返回false，当context更新时，不会引起下级组件的更新。

## 代码案例
1. 父子组件通信方式
   * 传递数据(父传子)与传递方法(子传父)
        > `./scr/02-advanced/01-ChildPropsParent.js`
        >
        > ```jsx
        > import React, { Component } from 'react'
        > 
        > class Navbar extends Component{
        > render(){
        > return <div style={{background:"red"}}>
        >   <button onClick={()=>{
        >     console.log("子通知符，让父的isShow 取反",this.props.event)
        >     this.props.event() // 调用父组件的函数
        >   }}>click</button>
        >   <span>navbar</span>
        > </div>
        > }
        > }
        > class Sidebar extends Component{
        > render(){
        >   return <div style={{background:"yellow",width:"200px"}}> 
        >       <ul>
        >           <li>11111</li>
        >           <li>11111</li>
        >           <li>11111</li>
        >           <li>11111</li>
        >           <li>11111</li>
        >           <li>11111</li>
        >       </ul>
        >   </div>
        > }
        > }
        > export default class App extends Component {
        > state={
        > isShow:false
        > }
        > handleEvent=()=>{
        > this.setState({
        >   isShow:!this.state.isShow
        > })
        > console.log("父组件定义的event事件")
        > }
        > render() {
        > return (
        > 
        >   <div>
        >     {/* <Navbar event={()=>{
        >       // this.setState({
        >       //   isShow:!this.state.isShow
        >       // })
        >       console.llog("父组件定义的event事件")
        >     }}></Navbar> */}
        >     <Navbar event={this.handleEvent} />
        >     {this.state.isShow && <Sidebar></Sidebar>}
        >   </div>
        > 
        > )
        > }
        > }
        > /**
        > 
        > * 父传子 ： 属性
        > * 子传父 ：回调函数callback
        >   */
        > ```
   * ref 标记
   
        > `./src/02-advanced/05-RefNameFrom.js`
        >
        > ```jsx
        > import React, { Component } from 'react'
        > // 一个简单的Antd 的Filed组件原理
        > class Filed extends Component{
        >     state={
        >     value:""
        >     }
        >     clear(){
        >         this.setState({
        >         value:""
        >         })
        >     }
        >     setVlaue(val){
        >         this.setState({
        >         value:val
        >         })
        >     }
        >     render(){
        >         return (
        >         // 受控组件
        >         <div style={{background:"yellow"}}>
        >           <lable>{this.props.label}</lable>
        >           <input type={this.props.type} onChange={(evt)=>{
        >             this.setState({
        >               value:evt.target.value
        >             })
        >           }} value={this.state.value}/>
        >         </div>
        >         )
        >     }
        > }
        > 
        > export default class App extends Component {
        >     username = React.createRef()
        >     password = React.createRef() 
        >     render() {
        >         return (
        >         <div>
        >           <h1>登录页面</h1>
        >           <Filed label="用户名" type="text" ref={this.username}></Filed>
        >           <Filed label="密码" type="password" ref={this.password}></Filed>
        >           <button onClick={()=>{
        >             console.log('拿到当前DOM/组件实例',this.username.current)
        >               console.log(this.username.current.state.value,this.password.current.state.value)
        >           }}>登录</button>
        >           <button onClick={()=>{
        >             this.username.current.clear()
        >             this.password.current.clear()
        >           }}>取消保存</button>
        >         </div>
        >         )
        >     }
        > }
     > ```
   
2. 非父子组件的通信方式

   * 状态提升(中间人模式)
       > ![](https://i0.hdslb.com/bfs/album/a76ae98199981386be6233aab5e8fbcc49b47b37.png)
       > `./src/02-advanced/06-intermediary.js`
       >  ```jsx
       > import React, { Component } from 'react'
       > import axios from 'axios'
       > import './css/maizuo.css'
       > export default class App extends Component {
       > constructor() {
       >  super()
       >  this.state = {
       >    filmList: [],
       >    info:''
       >  }
       >  axios.get(`test.json`).then(res => {
       >    console.log(res.data.data.films)
       >    this.setState({
       >      filmList: res.data.data.films
       >    })
       >  })
       > }
       > render () {
       >  return (
       >    <div>
       >      {
       >        this.state.filmList.map(item =>
       >          <FilmItem key={item.filmId} {...item} onEvent={(value)=>{
       >            console.log("父组件接收value",value)
       >            this.setState({
       >              info:value 
       >            })
       >          }}></FilmItem>
       >        )
       >      }
       >      <FilmDetail info={this.state.info}></FilmDetail>
       >    </div>
       >  )
       > }
       > }
       > 
       > // 受控组件
       > class FilmItem extends Component {
       > render () {
       >  console.log('FilmList', this.props)
       >  const { name, poster,grade,synopsis } = this.props
       >  return <div className='filmitem' onClick={()=>{
       >    this.props.onEvent(synopsis) // 调用父组件并传入数据
       >  }}>
       >    <img src={poster} alt={name}></img>
       >    <h4>{name}</h4>
       >    <div>观众评分：{grade}</div>
       >  </div>
       > }
       > }
       > 
       > class FilmDetail extends Component {
       > render(){
       >  return <div className='filmdetail'>
       >    {this.props.info}
       >  </div>
       > }
       > }
       >  ```
   
   * 发布订阅模式实现
       > ![](https://i0.hdslb.com/bfs/album/00b4c73b3861e952183a00dd66b06eedde1b1c65.png)
       > ![](https://i0.hdslb.com/bfs/album/38b690096717d0c9a6fd97e436acb60bb620216e.png)
       > ```jsx
       > import React, { Component } from 'react'
       > import axios from 'axios'
       > import './css/maizuo.css'
       > 
       > // 调度中心
       > var bus ={
       >   list:[],
       >   //订阅
       >   subscribe(callback){
        >     this.list.push(callback)
        >   },
        >   // 发布
        >   publish(text){
        >     this.list.forEach(callback=>{
        >       callback && callback(text)
        >     })
        >   }
        > }
        > 
        > export default class App extends Component {
        >   constructor() {
        >     super()
        >     this.state = {
        >       filmList: []
        >     }
        >     axios.get(`test.json`).then(res => {
        >       console.log(res.data.data.films)
        >       this.setState({
        >         filmList: res.data.data.films
        >       })
        >     })
        >   }
        >   render () {
        >     return (
        >       <div>
        >         {
        >           this.state.filmList.map(item =>
        >             <FilmItem key={item.filmId} {...item} ></FilmItem>
        >           )
        >         }
        >         <FilmDetail></FilmDetail>
        >       </div>
        >     )
        >   }
        > }
        > 
        > // 受控组件
        > class FilmItem extends Component {
        >   render () {
        >     console.log('FilmList', this.props)
        >     const { name, poster,grade,synopsis } = this.props
        >     return <div className='filmitem' onClick={()=>{
        >       console.log(synopsis)
        >       bus.publish(synopsis)
        >     }}>
        >       <img src={poster} alt={name}></img>
        >       <h4>{name}</h4>
        >       <div>观众评分：{grade}</div>
        >     </div>
        >   }
        > }
        > 
        > class FilmDetail extends Component {
        >   constructor(){
        >     super()
        >     this.state={
        >       info:''
        >     }
        >     bus.subscribe((info)=>{
        >       console.log("我再filmDetail中定义",info)
        >       this.setState({
        >         info:info
        >       })
        >     })
        >   }
        >   render(){
        >     return <div className='filmdetail'>
        >       {this.state.info}
        >     </div>
        >   }
        > }
        > ```

   * context
        > ![](https://i0.hdslb.com/bfs/album/4d8b21f9cc949bc804ed9398cbe5eeb16216a945.png)
        > ./src/02-advanced/09-context.js
        >
        > ```jsx
        >   import React, { Component } from 'react'
        >   import axios from 'axios'
        >   import './css/maizuo.css'
        > 
        >   const GlobalContext = React.createContext() // 创建context上下文对象
        >   export default class App extends Component {
        >     constructor() {
        >       super()
        >       this.state = {
        >         filmList: [],
        >         info:''
        >       }
        >       axios.get(`test.json`).then(res => {
        >         console.log(res.data.data.films)
        >         this.setState({
        >           filmList: res.data.data.films
        >         })
        >       })
        >     }
        >     render () {
        >       return (
        >         // GlobalContext.Provider 供应商组件
        >         <GlobalContext.Provider value={
        >           {
        >             call:"打电话",
        >             sms:"短信",
        >             info:this.state.info,
        >             changeInfo:(val)=>{
        >               this.setState({
        >                 info:val
        >               })
        >             }
        >           }
        >         }>
        >           <div>
        >             {
        >               this.state.filmList.map(item =>
        >                 <FilmItem key={item.filmId} {...item} ></FilmItem>
        >               )
        >             }
        >             <FilmDetail></FilmDetail>
        >           </div>
        >         </GlobalContext.Provider>
        >       )
        >     }
        >   }
        > 
        >   // 受控组件
        >   class FilmItem extends Component {
        >     render () {
        >       console.log('FilmList', this.props)
        >       const { name, poster,grade,synopsis } = this.props
        >       return (  
        >         <GlobalContext.Consumer>
        >           {
        >             (value)=>{
        >               console.log(value)
        >               return <div className='filmitem' onClick={()=>{
        >                 console.log(synopsis)
        >                 value.changeInfo(synopsis)
        >                 }}>
        >                 <img src={poster} alt={name}></img>
        >                 <h4>{name}</h4>
        >                 <div>观众评分：{grade}</div>
        >               </div>
        >             }
        >           }
        >       </GlobalContext.Consumer>
        >       )
        >     }
        >   }
        > 
        >   class FilmDetail extends Component {
        >     render(){
        >       return (
        >         <GlobalContext.Consumer>
        >         {
        >           // (value)=>{
        >           //    return <div className='filmdetail'>
        >           //     {value.info}
        >           //   </div>
        >           // }
        >           (value)=><div className='filmdetail'>
        >             {value.info}
        >           </div>
        >           }
        >         </GlobalContext.Consumer>
        >       )
        >     }
        > }
        > ```
        >
        > 
      
   * 插槽

       > `./src/02-advanced/10-slot.js`
       > 
      > ```jsx
      > import React, { Component } from 'react'
      > 
      > class Child extends Component{
      >     render(){
      >         return <div>
      >             child
      > 
      >             {/* 插槽 vue slot,具名插槽 */}
      > 
      >             {this.props.children[2]}
      >             {this.props.children[1]}
      >             {this.props.children[0]}
      >         </div>
      >     }
      > }
      > 
      > class Swiper extends Component{
      >     render(){
      >         return <div>
      >             {this.props.children}
      >         </div>
      >     }
      > }
      > 
      > export default class App extends Component {
      >     render() {
      >         return (
      >             <div>
      > 
      >                 <Swiper>
      >                     <div>111111</div>
      >                     <div>222222</div>
      >                     <div>333333</div>
      >                 </Swiper>
      >                 <Swiper>
      >                     {/* <div><img/>111111</div>
      >                     <div><img/>222222</div>
      >                     <div><img/>333333</div> */}
      >                 </Swiper>
      >                 <Swiper>
      >                     {/* <img/>
      >                     <img/>
      >                     <img/> */}
      >                 </Swiper>
      > 
      >                 
      >                 <Child>
      >                     <div>11111111</div>
      >                     <div>22222222</div>
      >                     <div>33333333</div>
      >                     {
      >                         // children
      >                     }
      >                 </Child>
      >             </div>
      >         )
      >     }
      > }
      > 
      > 
      > /*
      >   1. 为了复用
      >   2. 一定程度减少父子通信。
      > */
      > 
      > ```

# React 生命周期

## 1. 初始化阶段

* componentWillMount: render 之前最后一次修改状态的机会<font color=red>已废弃</font>   

  加上前缀才不会报错 `UNSAFE_componentWillMount`

* render:只能访问`this.props`和`this.state`,不允许修改状态和DOM输出

* componentDidMount:成功render并渲染完成真实DOM之后触发，可以修改DOM

## 2.运行中阶段

* componentWillReceivePorps:父组件修改属性触发 <font color=red>已废弃</font>
* shouldComponentUpdate:返回false会阻止render调用
* componentWillUpdate:不能修改属性和状态
* render:只能访问this.props和this.state,不允许修改状态和DOM输出
* componentDidUpdate:可以修改DOM

## 销毁阶段

* componentWillUnmount: 在删除组件之前清理操作，比如计时器和事件监听器

## 老生命周期的问题

(1) componentWillMount ,在ssr中 这个方法将会被多次调用， 所以会重复触发多遍，同时在这里如果绑定事件，
将无法解绑，导致内存泄漏 ， 变得不够安全高效逐步废弃。

(2) componentWillReceiveProps 外部组件多次频繁更新传入多次不同的 props，会导致不必要的异步请求

(3) componetWillupdate, 更新前记录 DOM 状态, 可能会做一些处理，与componentDidUpdate相隔时间如果过长，会导致 状态不太信

## 新生命周期的替代

(1) getDerivedStateFromProps:第一次的初始化组件以及后续的更新过程中(包括自身状态更新以及父传子),返回一个对象作为新的state，返回null则说明不需要在这里更新state
> 初始化时候 可以替代 componentWillMount
> 父传子的时候 可以替代 componentWillReceivedProps

```jsx
// 老的生命周期
componentDidMount(){
  if(this.props.value !== undefined){
    this.setState({
      current:this.props.value
    })
  }
}
componentWillReceivePorps(nextProps){
  if(nextProps.value !== undefined){
    this.setState({
      current:nextProps.value
    })
  }
}
// 新的生命周期写法
static getDerivedStateFromProps(nextProps){
  if(nextProps.value !== undefined){
    return {
      current:nextProps.value
    }
  }
  return null
}

```

(2) getSnapshotBeforeUpdate 取代了componentWillUpdate，触发事件为update发生的时候，在render之后dom渲染之前返回一个值，作为**componentDidUpdate**的第三个参数。

```jsx
// 新的数据不断插入数据前面，导致我正在看的数据往下走，如何保持可视图依旧是我之前看到的数据呢?
getSnapshotBeforeUpdate(){
  return this.refs.wrapper.scrollHeight
}
componentDidUpdate(prevProps,prevState,preHeight){
  // if(preHeight===200)return ;
  this.refs.wrapper.scrollTop +=this.refs.wrapper.scrolHeight-preHeight
}
<div style={{height:"200px",overflow:"auto"}}} ref="wrapper"> <ul>......... </ul> </div>
```

**shouldComponentUpdate**优化性能的案例

```jsx
import React, { Component } from 'react'

class Box extends Component{
  // 加上优化性能
  shouldComponentUpdate(nextProps, nextState) {
    if(this.props.current === this.props.index || nextProps.current===nextProps.index){
      return true
    }
    return false // 返回false 阻止render调用
  }
  render(){
    // return <div style={{width:"100px",height:"100px",border:"1px solid gray",margin:"10px",float:"left"}}></div>
    return <div style={{width:"100px",height:"100px",border:this.props.current === this.props.index?"1px solid #64de64":"1px solid gray",margin:"10px",float:"left"}}></div>
  }
}
export default class App extends Component {
  state={
    list:["00","01","02","03","04","05","06","07","08","09"],
    current:0
  }
  render() {
    return (
      <div>
        <input type="number" onChange={(evt)=>{
          this.setState({
            current:Number(evt.target.value)
          })
        }} value={this.state.current}></input>
        <div style={{overflow:"hidden"}}>
          {
            this.state.list.map((item,index)=>
              <Box key={item} current={this.state.current} index={index}></Box>
              )
          }

        </div>
        <Box></Box>
      </div>
    )
  }
}

```

## react中性能优化的方案

1. shouldComponentUpdate
控制组件自身或子组件是否更新，尤其在子组件非常多的情况下，需要进行优化。
2. PureComponent
PureComponent会帮你 比较新props 跟 旧的props， 新的state和老的state（值相等,或者对象含有相同的属性、且属性值相等 ），决定shouldcomponentUpdate 返回true 或者false， 从而决定要不要呼叫 render function。
注意：
如果你的 state 或 props 『永远都会变』，那 PureComponent 并不会比较快，因为
 shallowEqual 也需要花时间。

# React Hooks

## 使用hooks 理由

1. 高阶组件为了复用，导致代码层级复杂
2. 生命周期的复杂
3. 写成 function组件，无状态组件 ，因为需要状态，又改成了class成本高

### useState(保存组件状态)

```jsx
const [state,setState] = useState(initialState)
```

### useEffect(处理副作用)和useLayoutEffect(同步执行副作用)

Function Component 不存在生命周期，所以不要把Class Component的生命周期概念搬过拉力试图对号入座。

```jsx
useEffect(()=>{
  // effect
  return ()=>{
    // cleanup
  }
},[依赖的状态;空数组,表示不依赖])
```

**不要对Dependencles撒谎，如果你明明使用了某个变量，却，没有申明在依赖中，你等于向React撒了谎，后果就是，当依赖的变量改变时，useEffect也不会再次执行，eslint会报错**
PreView页面改造成函数式组件，在路径上从id=1切换到id=2也会自动重新加载，比class组件方便

```jsx
let id=props.match.params.myid 
useEffect(()=>{
  axios.get(`/articles/${id}`).then(res=>{
    settitle(res.data.title)
    setcontent(res.data.content)
    setcategory(res.data.category)
  })
})
```

useEffect和useLayout有什么区别?
**简单来说就是调用时机不同， useLayoutEffect 和原来 componentDidMount & componentDidUpdate 一致，在react完成DOM更新马上同步调用的代码，会阻塞页面渲染。而 useEffect 是会在整个页面渲染完才会调用的代码**
官方建议优先使用 useEffect
> However, we recommend starting with useEffect first and only trying useLayoutEffect if that causes a problem.

在实际使用时如果想要避免**页面抖动**(在`useEffect`里修改DOM很有可能出现)的话，可以把需要操作DOM的代码放在`useLayoutEffect`里。在这里做点dom操作，这dom修改会和react做出的更改一起被一次性渲染到屏幕上，只有一次回流、重绘的代价。

### useCallback(记忆函数)

*防止因为组件重新渲染，导致方法被重新创建，气到缓存作用，只有第二个参数变化了，才重新声明一次*

```jsx
var handleClick = useCallback(()=>{
  console.log(name)
},[name])
<button onClick={()=>handleClick()}>click</button>

// 只有name改变后，这个函数才会重新声明一次。
// 如果传入空数组，那么就是第一次创建后就被缓存，如果name后期改变了，拿到的还是老的name。
// 如果不传入第二个参数，每一次都会重新声明一次，拿到的就是最新的name。
```

### useMemo 记忆组件

useCallback 的功能完全可以由useMemo所取代，如果你想要通过使用useMemo返回一个记忆函数也是完全的。

```jsx
useCallback(fn,input) is equivalent to useMemo(()=>fn, inputs)
// useCallback(fn,input) 等效于 useMemo(()=>fn, inputs)
```

唯一的的区别是:**useCallback不会执行第一个参数函数，而是将它返回给你，而是useMemo会执行第一个函数并且将函数执行结果返回给你。**所以在前面的例子汇总，可以返回handleClick来达到存储函数的目的。
所以useCallback常用记忆事件函数，生成记忆后的事件函数并传递给子组件使用。而useMemo更适合经过函数计算得到一个确定的值，比如记忆组件。

### useRef(保存引用值)

```jsx
const myswiper = useRef(null);
<Swiper ref={myswiper} />
```

### useReducer 和 useContext(减少组件层级)

```jsx
import React from 'react'
var GlobalContext = React.createContext()
// 注意此时的reducer 返回值是一个对象 {isShow:false,list:[]}
function App(){
    let [state,dispatch] = useReducer(reducer,{isShow:true,list:[]})
    return <GlobalContext.Provider value={{
                dispatch
            }}>
              <div>
              {
                  state.isShow?<div>我是选项卡</div>:null
              }
              {props.children}
              </div>
            </GlobalContext.Provider>
}

function Detail(){
    var [dispatch] = useContext(GlobalContext)
    useEffect(()=>{
        // 隐藏
        dispatch({
            type:"Show",
            payload:false
        })
        return ()=>{
            // 显示
            dispatch({
                type:"Show",
                payload:true
            })
        }
    },[])
    return <div>detail</div>
}
```

#### 自定义hooks

**当我们想在两个函数之间共享逻辑时，我们会把它提取到到三个函数中。**
必须以`use`开头吗？<font color=red>必须如此</font>。这个约定非常重要，不遵循的话，由于无法判断某个函数是否包含对其内部Hook的调用，React将无法自动检查你的Hook是否违反了Hook的规则。

# React Router(react-route-dom@6)

## 官方文档

> [**React Router 官方文档**](https://reactrouter.com/docs/en/v6)
>
## 安装

运行以下命令安装React-Router

```ssh
npm install react-router-dom@6
```

<font color=red>注意:</font>`react-router-dom`包含所有内容，导入组件是应该从`react-router-dom`中导入，而不应该从`react-router`中导入，否则，会意外地应用中导入不匹配的库版本;

## 基本用法

### **在web应用程序中开启 React router功能**

`index.js`

```jsx
import React from 'react';
import {createRoute} from 'react-dom/client';
import {BrowserRouter} from 'react-route-dom'
import App from './App'

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
// Connect the URl 通过在应用入口添加 BrowserRouter 组件开启React Route 功能
<BrowserRouter>
    <React.StrictMode>
      <App />
    </React.StrictMode>
</BrowserRouter>
```

<font color=red>注意：</font>web应用程序中一般使用`BrowserRouter`组件，还用另一种`HashRouter`组件方式；
这两种方式的区别:

1. 底层原理不一样：
    `BrowserRouter`调用的是**H5 history API**，低版本兼容性问题
    `HashRouter`使用的是**URL**哈希值；
2. 地址栏表现形式不一样
   `BrowserRouter`的路径: localhost:3000/index
   `HashRouter`的路径:locahost:3000/#/index
3. 刷新后对路由**state**参数的影响
   `BrowserRouter`没有任何影响，应为**state**保存在history对象中
   `HashRouter`刷新后会导致路由**state**参数的丢失
值得注意的是，官方强烈建议不要使用`HashRouter`;

### 配置路由

`./App.js`

```js
// 导入Route，Routes组件
import {Route,Routes} from 'react-router-dom'
export default function App(){
    return(
      <Routes>
      {/* Add some Routes*/}
      {/** 页面默认导航到 Home组件(页面上显示 Home Component)*/}
      <Route path='/' element={<Home />}
      {/* 在地址栏输入 localhost:3000/about 导航到 About组件(页面上显示 About Component）*/}
      <Route path='/about' element={<About />}
      <Routes>
    )
}

const Home=(props)=>{
    return <div>Home Componet</div>
}
const About=(props)=>{
    return <div>About Component</div>
}
```

在以前的版本 **React Router**中，必须以某种方式对路由进行排序，以便在多个路由与不明确的**URL**匹配时获得要呈现的正确路由，V6更智能，会选择最具体的匹配；

### 添加 “不匹配”路由

`./App.js`

```jsx
import {Route,Routes} from 'react-router-dom';
export default function App(){
    return(
    <Routes>
      <Route path='/' element={<Home />}/>
      <Route path='about' element={<About />} />
      {/* Adding a "No Match" Route 当没有其他路由与 URL 匹配时，匹配 path=‘*’的路由*/}
      <Route path='*' element={<NotFount />} />
    <Routes>
    )
}
const Home = (props) => {
  return <div>Home Compontent</div>;
}

const About = (props) => {
  return <div>About Compontent</div>;
}

const NotFount = (props) => {
  return <div>NotFount !!!</div>;
}
```

当没有其他路由与URL匹配时，才会`path='*'`路由。此路由将匹配任何URL，但优先级最弱，因为此路由器仅在没有其他路由匹配时才会选择它；

## 使用链接导航

`./App.js`

```jsx
// 导入Link 组件
import {Route,Routes} from 'react-router-dom';
export default function App(){
    return(
    <Routes>
      {/* 页面默认导航到 Home 组件(渲染 Home 组件, 页面显示 HomeCompontent 链接) */}
      <Route path='/' element={<Home />}/>
      <Route path='about' element={<About />} />
      <Route path='*' element={<NotFount />} />
    <Routes>
    )
}
const Home = (props) => {
  return <div>
      Home Compontent
      {/*点击About Link 链接跳转至 http://localhost:3000/about 
      画面显示 About 组件内容---(Home Link链接)
      */}
      <Link to='/about'>About Link</Link>
  </div>;
}

const About = (props) => {
  return <div>
      About Compontent
      {/*点击About Link 链接跳转至 http://localhost:3000/about 
      画面显示 Home 组件内容---(About Link链接) */}
       <Link to='/'>Home Link</Link>
  </div>;
}

const NotFount = (props) => {
  return <div>NotFount !!!</div>;
}
```

### 使用嵌套路由

`./App.js`

```jsx
// 导入Link，OutLet组件
import {Route,Routes,Link,Outlet} from 'react-router-dom'
export default function App(){
    return (
       <Routes>
      {/* 页面默认导航到 Home 组件(渲染 Home 组件, 页面显示 Home Compontent 链接) */}
       {/* Nested Routes*/}
      <Route path='/' element={<Home />}>
          <Route path='about' element={<About />} />
          <Route path='setting' element={<Setting />} />
          {/* 默认子路由 如果导航栏地址为 http://localhost:3000 , 此时子路由渲染位置(Outlet)为空白，增加一下配置，子路由渲染位置(Outlet)渲染 */}
           {/*Index Routes*/}
          <Route index element={<List />}/>
          <Route path='*' element={<NotFount />} />
      </Route>
    <Routes>
    )
}
const Home=(props)=>{
    return (
      <>
      <div>
          <Link to='/about'>About Link</Link> | {' '}
          <Link to='/setting'>Setting Link</Link>
      </div>
      <div style={{padding:'20px',margin:'10px',borderTop:'1px solid'}}>
          {/*Outlet 为嵌套子路由的出口，比如：点击About Link链接，
          浏览器地址变为 http://loalhost:3000/about 
          在此渲染路由地址 /about 的组件(在此显示：About Component)
          */}
          <Outlet />
      </div>
      
      </>
    )
}
const About = (props) => {
  return <div>
    About Compontent
  </div>;
}

const Setting = (props) => {
  return <div>
    Setting Compontent
  </div>;
}

const List = (props) => {
  return <div>
    List Compontent
  </div>;
}
```

这里**React Router**最强大的功能之一，在实际开发中，大多数UI都是一系列嵌套布局，**React Router**通过这种嵌套路由的方式实现了一些自动、持久的布局处理:

### 使用活动链接

`./App.js`

```jsx
// 导入NavLink组件
import {Route,Routes,NavLink,Outlet} from 'react-router-dom'
export default function App(){
   return (
    <Routes>
      <Route path='/' element={<Home />} >
        <Route path='about' element={<About />} />
        <Route path='setting' element={<Setting />} />
        <Route index element={<List />} />
      </Route>
    </Routes>
   );
}
const Home=(props)=>{
    return <>
      <div>
      {/* <NavLink /> 接收一个style或者 className 属性
      属性值为一个回调函数，可以通过 isActive的值判断
      链接是否处于活动状态，从而实现给活动链接添加样式的效果
      实例效果：点击哪个链接，目标链接字体变红
      */}
      <NavLink style={({isActive})=>navColor(isActive)} to='/about'>
        About LInk
      </NaLink> ?? {' '}
      <NavLink style={({isActive})=>navColor(isActive)} to='/setting'>
      Setting Link
      </NavLink>
      </div>
       <div style={{ padding: '20px', margin: '10px', borderTop: '1px solid' }}>
          <Outlet />
        </div>
    </>
}
const About = (props) => {
  return <div>
    About Compontent
  </div>;
}

const Setting = (props) => {
  return <div>
    Setting Compontent
  </div>;
}

const List = (props) => {
  return <div>
    List Compontent
  </div>;
}
const navColor=(isActive) =>{
    return {color:isActive?'red':''}
}
```

主要实现了给当前激活的链接设置一个样式，支持**style**和**className**这两种属性;

### 读取URL参数

`./App.js`

```jsx
import {Route,Routes,NavLink,Outlet,useParams} from 'react-router-dom'
export default function App(){
    <Routes>
      <Route path='/' element={<Home />}>
         <Route path='list' element={<List />}>
           <Route path=':id' element={<Item />}></Route>
         </Route>
      </Route>
    <Routes>
}
const Home=(props)=>{
    return <>
        <div>
      <NavLink
        style={({ isActive }) => navColor(isActive)}
        to='/list'
      >
        List Link
      </NavLink>
    </div>
    <div style={{ padding: '20px', margin: '10px', borderTop: '1px solid' }}>
      <Outlet />
    </div>
    </>
}
const Item=(props)=>{
    // 从 URL 获取参数： :id
    const params = useParams();
    return <h2>Item:{params.id}</h2>
}
const List=(props)=>{
    const list=[
        {
            name:'赵云',
            no:100
        },
        {
            name:'马超',
            no:101
        }
    ]
    return <div>
    {
        list.map((item)=>{
            return (
                <NavLink style={({isActive}) => navColor(isActive)} to={`/llist/${item.no}`} key={item.no}>
                </NavLink>
            )
        })
    }
    <div className='content'>
    {/*指定子路由 /list/? 的渲染位置*/}
    </div>
    </div>
}
```

## 与 V5的区别

1. `Routes>`替代 `<Switch>`
    写法上的比较:

    ```jsx
    // v5 写法
    // 引入 react-router
    import { Route, Switch } from 'react-router-dom';
    function App() {
      return (
          <Switch>
            {/* 路由配置 */}
          </Switch>
      );
    }
    // v6 写法
    import { Route, Routes } from 'react-router-dom';
    function App() {
      return (
          // Routes 替换 Switch
        <Routes> 
          {/* 路由配置 */}
        </Routes>
      );
    }
    
    ```

    v6 的优点：
    v6提供了强大的`Routes`组件来代替Switch组价，Routes不再按顺序匹配路径，而是采用了一种自动匹配最佳路径的方法；

2. `<Route>`不再支持子组件，改为element属性，并且不再需要exact 属性了
    写法上的比较：

    ```jsx
    // v5 写法
    // 引入 react-router
    import { Route, Switch } from 'react-router-dom';
    function App() {
      return (
          <Switch>
            <Route exact path='/home'>
              <Home />
            </Route>
          </Switch>
      );
    }
    // v6 写法
    import { Route, Routes } from 'react-router-dom';
    function App() {
      return (
        <Routes>
          <Route path='/home' element={<Home /> } />
        </Routes>
      );
    } 
    ```

    v6的优点：
    (1) v6提供的element属性，可以使开发者更方便的注入想要的props；
    (2) v6的path是相对的
    (3) 可以按照所需要的任何顺序放置路由，路由器将自动检测当前URL的最佳路由

3. 移除了`<NavLink>`的activeClassName属性
    v5的写法：

    ```jsx
    <NavLink to="home" activeClassName="highlight">
      Home
    </NavLink>
    ```

    v6写法:

    ```jsx
    import { NavLink } from 'react-router-dom';
    function App(){
        return (
            <>
            {/*className 写法*/}
            <NaLink
                className={({isActive})=>{
                    return isActive ? "highlight" : ""
                }}
                to="home">Home</NavLlink>
                
                {/*style 写法*/}
                <NavLink
                    to="about"
                    style={({isActive})=>{
                        return {
                            color:isActive?"red":""
                        }
                    }}
            </>
        )
    }
    ```

4. 移除`<Redirect>`，，改为使用`<Navigate>`
    写法上的对比:
    v5的写法

    ```jsx
    // to---新位置
      <Redirect to={{ pathname: '/login', state: { from: location }}}
    ```

    v6的写法

    ```jsx
    import {Navigate,Route,ROutes} from 'react-router-dom'
    function App(){
        return (
          <Routes>
            <Route path='/' element={<Navigate replace to='/home' /> } />
          </Routes>
        )
    }
    ```

5. `<Link to=''>`支持相对位置

    ```jsx
    // 配置路由
    <Route path="app">
        <Route path="home">
             <Route path="list" />
        </Route>
    </Route>
    
    // 当前 URL 是 /app/home
    <Link to="list">               => <a href="/app/home/list>
    <Link to="../list">            => <a href="/app/list>
    <Link to="../../list">         => <a href="/list>
    <Link to="../../../list">      => <a href="/list>
    ```

6. 新增`<Ooutlet>`
    关于`<Outlet>`，参考本文的**嵌套路由**节点；此组件是一个占位符，告诉React Router 嵌套的内容应该放到哪里；通过`<Outlet>`可以将所有的路由(嵌套的子路由)配置合并在一起，可进行路由的统一管理，增加了代码可维护性。

7. 使用`useNavigate`实现编程式导航，从而代替`useHistory`

   ```jsx
   // v6 写法
   import {useNavigate} from 'react-router-dom'
   function App(){
       const navigate = useNavigate()
       const handleClick=()=>{
           navigate('/home'); // push
           // 重定向
           // navigae('home',{replace:true})
       }
       return (
        <div>
          <button onClick={handleClick}>返回首页</button>
        </div>
      ); 
   }
   ```

   主要写法变更：
   * history.push("/") => navigate("/")
   * history.replace("/) => navigate("/",{replace:true})
   * history.goBack() => navigate(-1)
   * history.goForward => navigate(1)
   * history.go(2) => navigate(2)

8. 一系列的Hooks

    | Hooks名        | 作用                               | 说明                              |
    | -------------- | ---------------------------------- | --------------------------------- |
    | useParams      | 返回当前参数                       | 根据路径读取参数                  |
    | useNavigate    | 返回当前路由                       | 代替原有V5中的history、withRouter |
    | useOutlet      | 返回根据路由生成的element          |                                   |
    | useLocation    | 返回当前的location对象             |                                   |
    | useRoutes      | 同Routes组件一样，只不过在js中使用 |                                   |
    | useSearchParam | 用来匹配URL中 ? 后面的搜索参数     |                                   |

### 项目注意

(1)  反向代理
[官网地址](https://create-react-app.dev/docs/proxying-api-requests-in-development/)
**下载安装**

```ssh
npm install http-proxy-middleware --save
```

**使用**

```js
const {createProxyMiddleware} = require('http-proxy-middleware')
module.exports=function(app){
    app.use(
    '/api',
    createProxyMiddleware({
        target:'http://localhost:5000',
        changOrigin:true
    })
    )
}
```

(2) css module
[官网地址](https://facebook.github.io/create-react-app/docs/adding-a-css-modules-stylesheet)
**适用**

```js
全局
:global(.active){
    ....
}
局部样式
import style from './css/Film.module.css'
<div className={style.film}></div>
```

## 在类组件（class）中实现编程式导航

> [react router v6 类组件获取跳转](https://www.cnblogs.com/newBugs/p/15965558.html)

```jsx
import { Route, Routes, useNavigate } from "react-router-dom";
export const withNavigation = (Component) => {
  return (props) => <Component {...props} navigate={useNavigate()} />;
};

class ExmpleClassComponent extends Component {
    render(){
         return (
             // 没有使用高阶组件之前，props为空对象
             <div>this.props</div>
         )
    }
}
export default withNavigation(ExmpleClassComponent)

import { Route, Routes, useNavigate } from "react-router-dom";
export const withNavigation = (Component) => {
  return (props) => <Component {...props} navigate={useNavigate()} />;
};

class Films extends Component {
    render(){
         return (
             // 没有使用高阶组件之前，props为空对象
             <div>this.props</div>
             <div style={{position:"sticky",top:0,background:"white"}}>
              <Tabs onChange={(val)=>{
                  console.log('拿到高阶组价的props',this.props)
                // navigate(path)
                this.setState({
                  path:val
                })
                this.props.navigate(val)
              }} activeKey={this.state.path}>
                <Navigate to={this.state.path} replace='true' />
                <Tabs.Tab title='正在热映' key='/films/nowplaying'></Tabs.Tab>
                <Tabs.Tab title='即将上映' key='/films/comingsoon'></Tabs.Tab>
              </Tabs>
            </div>
         )
    }
}
export default withNavigation(Films)

```

```jsx
import React, { Component } from 'react'
import { Route, Routes,NavLink,useNavigate } from 'react-router-dom';
import style from './css/Film.module.css'
import { Swiper,Tabs } from 'antd-mobile'
import axios from 'axios'

// 由于是react-router-dom V6的原因，官方已经把history.push() 去除，因此需要利用高阶组价，拿到hook
export const withNavigation = (Component) => {
  return (props) => <Component {...props} navigate={useNavigate()} />;
}
class Films extends Component {

    state = {
    looplist:[],
    path:'/films/nowplaying'
    }
componentDidMount() {
    ....
}

    render() {
        return (
          // 嵌套路由 + 轮播 + Tabs选项卡
          <div className={style.film + 'aaaa'}>
            <div style={{position:"sticky",top:0,background:"white"}}>
              <Tabs onChange={(val)=>{
                  console.log('拿到高阶组价的props',this.props)
                // navigate(path)
                this.setState({
                  path:val
                })
                this.props.navigate(val)
              }} activeKey={this.state.path}>
                <Navigate to={this.state.path} replace='true' />
                <Tabs.Tab title='正在热映' key='/films/nowplaying'></Tabs.Tab>
                <Tabs.Tab title='即将上映' key='/films/comingsoon'></Tabs.Tab>
              </Tabs>
            </div>
            <Routes>
              <Route index path='nowplaying' element={<Nowplaying />} />
              <Route path='comingsoon' element={<Comingsoon />} />
            </Routes>
        </div>
        )
    }
}
export default withNavigation(Films)
```



# Flux与Redux

Flux是一种架构思想，专门解决软件的结构问题。它跟MVC架构是同一类东西，但是更加简单和清晰。Flux存在多种实现(至少15种)
> <https://github.com/voronianski/flux-comparison>

Facebook Flux是用来构建客户端Web应用的应用架构。它利用**单向数据流**的方式来组合React中的视图组件。它更像一个模式而不是一个正式的框架，开发者不需要太多的新代码就可以快速的上手Flux。
![](https://i0.hdslb.com/bfs/album/3f5e1659ee832c8c3bfebc80c45df204f90c6fee.png)
Redux最主要是用作应用状态的管理。简言之，Redux用一个单独的常量状态数(state对象)保存着一整个应用的状态，这个对象不能被直接改变。当一些数据变化，一个新的对象就会被创建(使用action和reducer),这样就可以进行数据追踪，实现时光旅行。

## 1. redux介绍及设计和使用的三大原则

* state以单一对象存储在store对象中
* state只读(每次都返回新的对象)
* 使用纯函数reducer执行state更新

## 2. redux工作流
![](https://i0.hdslb.com/bfs/album/6ff75113069f934f600378503551283e20839a1f.png)

## 3. 与react绑定后使用redux实现案例

```jsx
import {createStore} from 'redux'
const reducer =(state="defalutState,data={})=>{
    let {type,paload} = data
    switch(type){
        case 'changetitle':
            return payload
        defalut:
            return state
    }
}
const store = createStore(reducer)
export store;
```

```jsx
store.dispatch({
    type:'changetitle',
    payload:res.data.data.film.name
})
componentDidMount(){
    store.subscribe(()=>{
        this.setState({
            title:store.getStore()
        })
    })
}
```

```jsx
import {SHOW_TABBAR,HIDE_TABBAR} from '../../store/type'
```

## 4. redux原理解析
store是通过createStore创建出来的，所以它的结构

```js
export const createStore=function(reducer,initalState){
    ...
    return {
        ...
    }
}
```

dispatch,用于action的分发，改变store里面的state(currentState)=reducer(currentState,action),并在内部遍历subscribe注册的监听器
subscribe，注册listener，store里面state发生改变后，执行该listener
getState，取store里面的state

```jsx
function createStore(reducer){
    var list=[];
    var state=reducer();
    function subscribe(callback){
        list.push(callback)
    }
    function dispatch(data){
        state=reducer(state,data)
        for(var i in liat){
            list[i]()
        }
    }
    function getState(){
        return state;
    }
    return {
        subscribe,
        dispatch,
        getState
    }
    
}
```

## 5. reducer扩展
如果不同的action所处理的数学之间没有联系，我们可以把Reducer函数拆分。不同的函数负责处理不同的属性，最终把它们合并成一个大的Reducer即可。

```jsx
import {combineReducers} from 'redux'
const reducer = combineReducers({
    a:functionA,
    b:functionB,
    c:functionC
})
访问：
(state)=>{
    return {
        Iekakistate:state.a(不同的命名空间)
    }
}
```

## 6. redux中间件
 在redux里，action仅仅是携带了数据的普遍js对象。action creator返回的值是这个action类型的对象。然后通过store。dispatch()分发。同步的情况下一些都很完美，但是reducer无法处理异步的情况。
那么我们就需要action和reducer中间架起一座桥梁来处理异步，这就是middlewar  

① 中间件的由来与原理、机制

```jsx
export default functionthunkMiddleware({dispatch,getState}){ returnnext=>action=>
      typeofaction==='function'?
       action(dispatch,getState):
   next(action);
    }
```

 这段代码的意思是，中间件这个桥梁接受到的参数action，如果不是function则和过去一样直接执行next方法(下一步处理)，相当于中间件没有做任何事。如果action是function，则先执行action，action的处理结束之后，再在action的内部调用dispatch。

②  常用异步中间件：

 a. redux-thunk (store.dispatch参数可以是一个function)

 ```jsx
 importthunkfrom'redux-thunk';
 import{applyMiddleware}from"redux";
 const store=createStore(fetchReducer,applyMiddleware(thunk));
 { //进行异步请求
      return(dispatch,store)=>{
      ...
      }
  }
 ```

 b. redux-promise (store.dispatch参数可以是一个promise对象

 ```jsx
 import promiseMiddleware from 'redux-promise';
 conststore=createStore(fetchReducer,applyMiddleware(thunk,promiseMiddleware));
 const getComingSoon=()=>{
  //进行异步请求
  return axios.get(`****`).then(res=>{ 
      return{
        type:"cominglist",
        info:res.data.data
      }
 }
 ```


## 7. Redux DevTools Extension

> <https://github.com/zalmoxisus/redux-devtools-extension>

```js
import {createStore, compose} from 'redux'
import reducer from'./reducer'
const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;
const store = createStore(reducer,/*preloadedState,*/composeEnhancers())
exportdefaultstore
```

# react-redux

## 1. 介绍

> <https://github.com/reactjs/react-redux>

## 2. 容器组件与UI组件
(1) UI组件
    * 只负责UI的呈现，不带有任何的业务逻辑
    * 没有状态（即不使用this.state这个变量)
    * 所有的数据都由参数(this.props)提供
    * 不使用任何Redux的API
(2) 容器组件
    * 负责管理数据和业务逻辑，不负责UI的呈现
    * 带有内部状态
    * 使用Redux的API

## 3. Provider与connect
    (1) React-Redux 提供Provider组件，可以让容器组件拿到state。

  ```jsx
  import React from 'react'
  import ReactDOM from 'react-dom'
  import {Provider} from 'react-redux'
  import store from './store'
  import App from './App'
  const rootElement = document.getElementId('root')
  ReactDDOm.render(
  <Provider store={store}>
  <App />
  </Provider>,
  rootElement
  )
  ```

  (2)  React-Redux 提供action方法，用于UI组件生成容器组件，connect的意思，就是将这两种组件连起来

  ```jsx
  import {connect} from 'react-redux'
  import {increment,decrement,reset} from './actionCreators' //constCounter=...
  const mapStateToProps=(state/*,ownProps*/)=>{  
      return{
        counter:state.counter
       }
   }
   const mapDispatchToProps ={increment,decrement,reset}
   export default connect(
   mapStateToProps,
   mapDispatchToProps
  )(Counter)
  ```

## 4. HOC与context通信在react-redux底层中的应用
(1) connect是HOC，高阶组件
(2) Provider组件，可以让容器组件拿到state，使用context

## 5. 高阶组件构建与应用
HOC不仅仅是一个方法，确切说应该是一个组件工厂，获取低阶组件，生成高阶组件
(1) 代码复用，代码模块化
(2) 增删改props
(3) 渲染劫持

```js
// Child.js
// 高阶函数
function Control(wrappedComponent){
 return classMyControl extends React.Component{  
 render(){
       if(!this.props.data){
            return <div>loading...</div>
           }
       }
       return <wrapperComponent {...props} />
       }
   }
   export default Control(MyComponent);//高阶组件
```

```js
//Parent.js
import MyControlComponent from "./Child"
<MyControlComponent data={this.state.value}/>
//在父级传入data是null的时候，这一块儿就只会显示loading...,
//不会显示组件的具体内容，如果data不为null,就显示真实组件信息。
```

## 6. Redux持久化

**[rt2zz/redux-persist: persist and rehydrate a redux store (github.com)](https://github.com/rt2zz/redux-persist)**

```js
import {persistStore,persistReducer} from 'redux-persist';
import storage from 'redux-persist/lib/storage';
import autoMergeLevel2 from 'redux-persist/lib/stateReconciler/autoMergeLevel2';
const persistConfig={
  key:'kerwin',
  storage:storage,
  //localStorage:importstoragefrom'redux-persist/lib/storage'
  //sessionStorage:importstorageSessionfrom'redux-persist/lib/storage/session'  
  stateReconciler:autoMergeLevel2
  //控制在本地存储中，新老状态怎么合并，覆盖？或者合并？
};
//改造reducer
const myPersistReducer = persistReducer(persistConfig,reducer)
//改造store
export constpersistor = persistStore(store)
//改造根组件
import {persistor} from'./Store'
import {PersistGate} from'redux-persist/lib/integration/react';
<PersistGateloading={null}persistor={persistor}>     
...
</PersistGate>
```

# UI组件库

**1.  ant-design（PC端）** 

https://ant.design/index-cn 

https://ant-design.gitee.io/index-cn (镜像库，快)

**2. antd-mobile（移动端）**
https://mobile.ant.design

# Immutable

```js
var obj={ // 一个复杂结构的对象 
    ...
}
doSomething(obj)
// 上面的函数之行完后，此时的 obj 还是最初的那个 obj 吗？ // deepCopy？
```

## 1. Immutable.js 介绍

> 与Immutable类似，不可变数据结构
>
>  [Immer 入门 | Immer (immerjs.github.io)](https://immerjs.github.io/immer/zh-CN/) 

https://github.com/immutable-js/immutable-js

缺点：容易和原生混淆，文档与调式不方便

每次修改一个Immutable对象时都会创建一个新的不可变的对象，在新对象上操作并不会影响到原对象的数据。

这个库的实现是深拷贝还是浅拷贝?

## 2.深拷贝与浅拷贝的关系

(1) var arr={ };arr2=arr;

(2) Object.assign() 只是一级属性复制，比浅拷贝多拷贝一层而已。

(3) const obj1=JSON.parse(stringify(obj)); 数组，对象都好用的方法(缺点：不能有undefined，否则会造成不可预期的后果)

## 3.Immutable优化性能的方式

Immutable实现的原理是Persistent Data Structure(持久化数据结构)，也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变。同时为了避免deepCopy把所有节点都复制一遍带来的性能消耗，Immutable使用了Structural Sharing(结构共享)，即如果对象数中一个节点发生变化，只修改这个节点和受它影响的父节点，其他节点则进行共享。

 https://upload-images.jianshu.io/upload_images/2165169-cebb05bca02f1772 

## 4.Immutable中的常用类型(Map,List) typeScript定义数据结构

### (1) Map 无序索引集，类似`JavaScript`中Object

* Map常用方法

  ```ini
   Map<K, V>(): Map<K, V>
   Map<K, V>(iter: Iterable.Keyed<K, V>): Map<K, V>
   Map<K, V>(iter: Iterable<any, Array<any>>): Map<K, V>
   Map<K, V>(obj: Array<Array<any>>): Map<K, V>
   Map<V>(obj: {[key: string]: V}): Map<string, V>
   Map<K, V>(iterator: Iterator<Array<any>>): Map<K, V>
   Map<K, V>(iterable: Object): Map<K, V>
  
  ```

  

* 构建`Map`对象 `Map()`

   构造函数不常用，一般都是通过`Immutable.fromJS()`将一个`JS`原生对象转换为一个`Immutable`对象 

  ```js
  const data=Map({title:'大峡谷'})
  console.log(data)
  ```

  ![](https://i0.hdslb.com/bfs/album/2468d36fcc39cdf13270fe69a1bc0c2603172ccd.png)

* `Map.of()` 构建`Map`对象 这是另外一种构建`Map`对象的方法

  ```ini
  const data = Map.of('key1','value1','key2','value2','key3','value3'); 
  ```

  ![](https://i0.hdslb.com/bfs/album/2d96d777d0cd65df4adf21ad1773126ce7bfedb5.png)

* `Map().toJS()` 将`Map`对象转化为普通对象

  ```js
  const data=Map({title:'大峡谷'})
  console.log(data.toJS()); // {title:'大峡谷'}
  ```

* `Map.isMap({})` 判断对象是否是`Map`对象 对原生`Object`不生效

  ```js
  console.log(Map.isMap({})); // false
  console.log(Map.isMap(Map({}))); // true
  ```

  

* `Map.size()` `size` 这是`Map`的一个静态属性，用于获取对象属性的个数

  ```js
  console.log(Map({key: "value2", key1: "value1"}).size);// 2
  console.log(Map.of({x:1}, 2, [3], 4).size);// 2
  ```

  

* 添加元素`Set`方法

  ```js
  const data = Map({a: {a1: 34}, b: 2, c: 3, d: 444});
  console.log(data.set('a', 0).toJS()); // {a: 0, b: 2, c: 3, d: 444}
  console.log(data.set('e', 99).toJS());  // {a: 1, b: 2, c: 3, d: 444, e: 99}
  ```

  

* 添加元素`setIn`方法

  ```js
  console.log(Immutable.fromJS([1, 2, 3, {a: 45, b: 64}]).setIn(['3', 'a'], 1000).toJS());//[1, 2, 3, {a: 1000, b: 64}]
  
  ```

  

* `mapKeys()` `mapEntries()` 对`Map`元素进行处理，返回处理后的对象

  ```js
  //mapKeys() 返回对象
  console.log(Immutable.fromJS({a: 5, b: 2, c: 3, d: 444}).mapKeys((key)=>{
      return key + 'hhh';
  }).toJS());
  // {ahhh: 5, bhhh: 2, chhh: 3, dhhh: 444}
  
  //mapEntries() 返回对象
  console.log(Immutable.fromJS({a: 5, b: 2, c: 3, d: 444}).mapEntries(([key, value])=>{
      return [key + 'aaa', value+'hhhh'];
  }).toJS());//   {aaaa: "5hhhh", baaa: "2hhhh", caaa: "3hhhh", daaa: "444hhhh"}
  ```

  

*  `merge`合并方法 `merge()` `mergeDeep()` `mergeWith()` `mergeDeepWith()`

  ```js
  // Map
  const $test = Immutable.fromJS({a: {a1: 222, a3: 456}, b: 2, c: 3, d: 444});
  const $test1 = Immutable.fromJS({a: {a1: 222, a2: 234}, b: 2, c: 3, d: 444});
  
  // 浅merge
  console.log($test.merge($test1).toJS(), $test.toJS());
  // $test1 -> $test {a: {a1: 222, a2: 234}, b: 2, c: 3, d: 444} {a: {a1: 222, a3: 456}, b: 2, c: 3, d: 444}
  // 深merge
  console.log($test.mergeDeep($test1).toJS(), $test.toJS());
  // $test1 -> $test {a: {a1: 222, a2: 234, a3: 456}, b: 2, c: 3, d: 444} {a: {a1: 222, a3: 456}, b: 2, c: 3, d: 444}
  
  // 浅merge自定义merge规则
  console.log($test.mergeWith((prev, next)=> {
      // 自定义转换
      return prev;
  }, $test1).toJS(), $test1.toJS());
  // 深merge自定义merge规则
  console.log($test.mergeDeepWith((prev, next)=> {
      // 自定义转换
      return prev;
  }, $test1).toJS(), $test1.toJS());
  ```

  

* `join()` 将对象转换为字符串

  ```js
  console.log(Immutable.fromJS({b: 2, a: {a1: 222, a3: 456}, c: 3, d: 444}).join()); // 2,Map { "a1": 222, "a3": 456 },3,444
  ```

  

* `isEmpty()` 判断Map对象是否为空

  ```js
  console.log(Immutable.fromJS({}).isEmpty()); // true
  ```

  

* `has()` `hasIn()` 检查是否有某个key

  ```js
  console.log(Immutable.fromJS({b: 2, a: {a1: 222, a3: 456}, c: 3, d: 444}).has('a')); // true
  console.log(Immutable.fromJS({b: 2, a: {a1: 222, a3: 456}, c: 3, d: 444}).hasIn(['a', 'a3'])); // true
  ```

  

* `includes()` 是否包含某些元素

  ```js
  // 对象是否包含某个元素，对Immutable元素使用Immutable.is 进行比较
  console.log(Immutable.fromJS({b: 2, a: {a1: 222, a3: 456}, c: 3, d: 89}).includes('89'));// 数组没有字符89，所以返回 false
  console.log(Immutable.fromJS({b: 2, a: {a1: 222, a3: 456}, c: 3, d: '89'}).contains('89'));// true
  console.log(Immutable.fromJS({b: 2, a: {a1: 222, a3: 456}, c: 3, d: Immutable.fromJS([6, 5, 4])}).contains(Immutable.fromJS([6, 5, 4])));// true
  ```

  

* `isSubset()` 子集判断

  ```js
  // isSubset()
  console.log(Immutable.fromJS({b: 2, a: {a1: 222, a3: 456}}).isSubset(Immutable.fromJS({b: 2, a: {a1: 222, a3: 456}, c: 3, d: 5})));// true
  // isSuperset 就是 isSubset 参数掉个个儿
  console.log(Immutable.fromJS({b: 2, a: {a1: 222, a3: 456}, c: 3, d: 5}).isSuperset(Immutable.fromJS({b: 2, a: {a1: 222, a3: 456}})));// true
  ```

  

* `reverse()` 反转

  ```js
  console.log(Immutable.fromJS({b: 2, a: {a1: 222, a3: 456}, c: 3, d: 5}).reverse().toJS());
  // {d: 5, c: 3, a: {a1: 222, a3: 456}, b: 2}
  ```

  

* 排序方法 `sort()`和`sortBy()` `sortBy(comparatorValueMapper: (value: T, key: number, iter: Iterable) => C,comparator?: (valueA: C, valueB: C) => number): Iterable`

  ```js
  console.log(Immutable.fromJS({b: 2, a: 88, c: 3, d: 5}).sort().toJS());// {b: 2, c: 3, d: 5, a: 88}
  // 传入比较函数
  console.log(Immutable.fromJS({b: 2, a: 88, c: 3, d: 5}).sort((a, b) => {
      if (a < b) {
          return -1;
      }
      if (a > b) {
          return 1;
      }
      if (a === b) {
          return 0;
      }
  }).toJS());// {b: 2, c: 3, d: 5, a: 88}
  // sortBy
  console.log(Immutable.fromJS({b: {a: 2}, a: {a: 88}, c: {a: 3}, d: {a: 5}}).sortBy((value, key, obj)=> {
      return value.get('a')
  },(a, b) => {
      if (a < b) {
          return -1;
      }
      if (a > b) {
          return 1;
      }
      if (a === b) {
          return 0;
      }
  }).toJS());// {b: {a: 2}, c: {a: 3}, d: {a: 5}, a: {a: 88}}
  ```

  

* `flatten()` 平铺 参数默认情况下，false 深度平铺，true 浅度平铺1层

  ```js
  console.log(Immutable.fromJS({b: 2, a: {a1: {a5: 333}, a3: [1,2,3]}, c: 3, d: 5}).flatten().toJS());
  // {0: 1, 1: 2, 2: 3, b: 2, a5: 333, c: 3, d: 5}
  console.log(Immutable.fromJS({b: 2, a: {a1: {a5: 333}, a3: [1,2,3]}, c: 3, d: 5}).flatten(true).toJS());
  // {b: 2, a1: Object, a3: Array[3], c: 3, d: 5}
  ```

  

* `groupBy()` 分组

  ```js
  console.log(Immutable.fromJS({b: {a5: 333}, a: {a5: 333}, c: {a5: 334}, d: {a5: 334}}).groupBy((value) => {
      return value.get('a5')
  }).toJS());
  // OrderedMap  {333: {b: {a5: 333}, a: {a5: 333}}, 334: {c: {a5: 334}, d: {a5: 334}}}
  ```

  

* 连接 `concat()`

  ```js
  const $test1 = Immutable.fromJS({b: 2, a: {a1: {a5: 333}, a3: [1,2,3]}, c: 3, d: 5});
  const $test2 = Immutable.fromJS({b1: 22, b: 34});
  console.log($test1.concat($test2).toJS()); //{b: 34, a: Object, c: 3, d: 5, b1: 22} 属性 b 被覆盖
  console.log($test1.toJS(), $test2.toJS()); //{b: 2, a: {a1: {a5: 333}, c: 3, d: 5} b1: 22, b: 34}
  ```

  

* 练习

```js
consnt {Map} = require('immutable')
const map1 = Map({a:1,b:2,c:3})
const map2 = map1.set('b',50)
map1.get('b') + "VS." + map2.get('b') // 2 VS 50
```

```jsx
import {Map} from 'immutable'
let a = Map({
    select:'users',
    filter:Map({name:'Cam'})
})
let b = a.set('select','pepole')
a===b; // false
a.get('filter') === b.get('filter') // true
```

延深：如果上述select属性给一个组件用，因为此值改变了，shouldComponentUpdate 应该返回 true，而filter属性给另一个组件用，通过判断并无变化，shouldComponent，应该返回false，此组件就避免了重复进行diff对比

### (2) List 有序索引集，类似于`JavaScript`中的Array

* 静态方法 

  * `isLlist`，用于判别是否是List结构的数据

  ```js
  const arr = [1,2,3]
  const list = List(arr)
  console.log(List.isList(arr)) // false
  console.log(List.isList(list)) // true
  ```

  * `of`，用于创建一个List数组结构

  ```js
  const list = List.of(1,2,3,4)
  console.log(list)
  ```

  打印结构如图：是一个List结构的数据对象

  ![](https://i0.hdslb.com/bfs/album/e23bb6168360e5c2aa3d4b24fdb97ad5f86ab431.png)

* 属性

  `size` 这是`List`的一个静态属性，与数组的`length`使用方法一样

  ```js
  const arr=[1,2,3]
  const list = List(arr)
  const size = list.size()
  console.log(size) // 3
  ```

* List方法

  1. **toJs():Array** `toJS()`方法是将List对象转为普通的js对象：

     ```js
     const arr = [1,2,3]
     const list = List(arr)
     consnt newList=list.toJS()
     cosole.log(newList) // [1,2,3]
     ```

  2. **toJSON():Array** `toJS()`方法是将List对象转为普通的json对象

     ```js
     const arr= [1,2,3]
     const list=List(arr)
     const newList = list.toJSON()
     console.log(newList) // [1,2,3]
     ```

  3. **toArray:Array** `toArray()`方法是将List对象转为普通的array对象

     ```js
     const arr=[1,2,3]
     const list = List(arr)
     const newList = list.toArray()
     console.log(newList) // [1,2,3]
     ```

  4. **toObject:Array** ·toObject方法是将List对象转为普通的object对象

     ```js
     const arr=[1,2,3]
     const list=List(arr);
     const newList = list.toObject()
     console.log(newList) // {0:1,1:2,2:3}
     ```

  5. **set(index:number,value:T):LIst** `set`是用于设置特定位置的数据的一个方法：

     ```js
     const arr = [1, 2, 3];
     const list = List(arr);
     const newList = list.set(1, 'a');
     console.log(list.toJS()); // [1,2,3]
     console.log(newList.toJS()); //[1,'a',3]
     ```

  6. **get(index:number):T | undefined** `get`方法用于获取特定位置的元素

     ```js
     const arr=[1,2,3]
     const list=List(arr);
     const value = list.get(1);
     console.log(value); //2
     ```

  7. **delete(index:number):List** `delete`方法用于删除数组中一个元素

     ```js
     const arr =[1,2,3]
     const list=List(arr)
     cosnt newList=list.delete(1) // 删除第二个元素
     consloe.log(newList.toJS()) // [1,3]
     ```

     

  8. **insert(index:number,value:T):List** `insert`方法用于往指定的位置插入一个元素

     ```js
     const arr=[1,2,3]
     const list=List(arr);
     const newList = list.insert(2, 'a');
     console.log(newList.toJS()); //[1,2,'a',3]
     ```

  9. **clear():List** `clear`方法用于清空对象

     ```js
     const arr=[1,2,3]
     const list=List(arr);
     const newList = list.clear(); 
     console.log(newList.toJS()); //[]
     ```

  10. **update(index:number,updater:(value:T)=>T):List** `update`方法用于更新数组中的元素，接受两个参数，`updater`接受一个函数，参数是旧数据返回值哟啊更新的数据

      ```js
      const arr=[1,2,3]
      const list=List(arr);
      const newList = list.update(1, (value)=>{
          return value*2;
        })
      console.log(list.toJS()); //[1,2,3]
      console.log(newList.toJS()); //[1,4,3]
      ```

  11. **insert(index:number,value:T):List**`insert`方法用于 将指定元素插入到不可变列表中的指定索引位置 

      ```js
      const arr=[1,2,3]
      const list=List(arr);
      const newList = list.insert(1,8)
      console.log(newList) // [1,8,2,3]
      ```
      
  12. **setSize(size:number):List** `setSize`方法用于设置List对象的长度大小，，超出的部分值为`undefined`
  
    ```js
      const arr=[1,2,3]
      const list=List(arr);
      console.log(list.size) // 3
      const newList=listSize(5)
      console.log(newList.toJS())//[1,2,3,undefined,undefined]
      console,log(newList.size) //5
    ```
  
  13. **setIn(keyPath:Iterable,value:any):this**`setIn`方法用于设置指定位置的值，与`set`方法很类似，但是可以处理更复杂的数据结构( 可以解决上面最开始的那个操作数据嵌套过深的问题)
  
      ```js
      const list = List([1, 2, 3, [4, 5, [6, 7], 8], 9, 10]);
      const newList = list.setIn([3, 2, 1], 'a'); // 设置第三个元素[4,5[6,7],8]中的第二个元素[6,7]中的第一个元素7为'a'
      console.log(newList.toJS()) //[1, 2, 3, [4, 5, [6, 'a'], 8], 9, 10]
      ```
  
      ```js
       const list = List([1, 2, 3, [4, 5, {name: '张三'}, 8], 9, 10]);
        // 凡是有In的操作方法，第一个参数需要接收数据所在的路径。
       const newList = list.setIn([3, 2, 'name'], '李四');
       console.log(newList.toJS()) //[1, 2, 3, [4, 5, {name: '李四'}, 8], 9, 10]
      ```
  
  14. **deleteIn(keyPath:Iterable):this**`deleteIn`方法用于删除指定位置的值，与`delete`方法类似，但是可以处理更复杂的数据结构
  
      ```js
      const list = List([1, 2, 3, [4, 5, [6, 7], 8], 9, 10]);
      const newList = list.deleteIn([3, 2, 1]); // 删除第三个元素[4,5[6,7],8]中的第二个元素[6,7]中的第一个元素7
      console.log(newList.toJS()) //[1, 2, 3, [4, 5, [6], 8], 9, 10]
      ```
  
  15. **updateIn(keyPath: Iterable): this** `updateIn`方法用于删除指定位置的值，与`delete`方法很类似，但是可以处理更复杂的数据结构,注：`updateIn`与`setIn`的区别在于`updateIn`需要依赖旧值改变数据
  
      ```js
      const list = List([1, 2, 3, [4, 5, [6, 7], 8], 9, 10]);
      const newList = list.updateIn([3, 1],(value=>value*3));
       // 删除第三个元素[4,5[6,7],8]中的第二个元素[6,7]中的第一个元素7
      console.log(newList.toJS()) //[1, 2, 3, [4, 15, [6,7], 8], 9, 10]
      ```
  
  16. **concat(...valuesOrCollections: Array): List** `concat`方法与原生的数组`concat`方法类似，用法基本相同。
  
      ```js
      const arr1=[1,2,3];
      const arr2=[4,5,6];
      const list1=List(arr1)
      const list2=List(arr2)
      const newList=list1.concat(list2)
      console.log(newList); 
      ```
  
       打印结果如图 :
  
      ![](https://i0.hdslb.com/bfs/album/73924898ae9cd52096c5c38d9178539c4e06b6b7.png)
  
  17. **merge()** `merge`用于合并两个List结构的数据，merge方法效果和concat方法一样，这里不做过多的解释
  
      ```js
      const arr1=[1,2,3];
      const arr2=[4,5,6];
      const list1=List(arr1)
      const list2=List(arr2)
      const newList=list1.merge(list2)
      console.log(newList); 
      ```
  
  18.  ap(mapper: (value: T, key: number, iter: this) => M, context?: any): List `map`方法用于遍历数据，并返回执行函数后的一个新的数据，得到的仍然是个`List`结构的数据 
  
      ```js
      const arr = [1, 2, 3];
      const list = List(arr);
      const newList = list.map((item) => item * 2); //将数组的每一项乘以2
      console.log(newList);
      ```
  
       打印结构如下： 
  
      ![](https://i0.hdslb.com/bfs/album/d2d1052b2970a3c88391bddfba47f82205817458.png)
  
  19. **forEach(mapper: (value: T, key: number, iter: this) => void, context?: any): void** `forEach`方法用于遍历数据，与原生方法一样
  
      ```js
      const arr = [1, 2, 3];
      const list = List(arr);
      list.forEach((item) => {
          console.log(item) // 1 2 3
      }); //将数组的每一项乘以2
      console.log(newList);
      ```
  
  20. **filter()** `filter`方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。
  
      ```js
          const arr = [1, 2, 3, 4, 5, 6, 7];
          const list = List(arr);
          const newList = list.filter((item) => item > 5); //将大于5的元素筛选出来
          console.log(newList.toJS()); //[6,7]
      ```
  
  21. **find()** `find`方法返回数组中满足提供的测试函数的第一个元素的值
  
      ```js
      const arr = [1, 2, 3, 4, 5, 6, 7];
      const list = List(arr);
      const item = list.find((item) => item > 5);
      console.log(item); //[6]
      ```
  
  22. **findLast()** `findLast`方法**从后往前**找返回数组中满足提供的测试函数的第一个元素的值
  
      ```js
      const arr = [1, 2, 3, 4, 5, 6, 7];
      const list = List(arr);
      const item = list.findLast((item) => item > 5);
      console.log(item); //[7]
      ```
  
  23. **findIndex()** `findIndex()`方法返回数组中满足提供的测试函数的第一个元素的索引。若没有找到对应元素则返回-1。
  
      ```js
      const arr = ["菠萝", "苹果", "香蕉", "梨子"];
      const list = List(arr);
      const index = list.findIndex((item) => item === "香蕉");//找出数组中元素为"香蕉"的元素下标
      console.log(index); // 2
      ```
  
  24. **findLastIndex()** `findIndex()`方法**从后往前**找返回数组中首次满足提供的测试函数的第一个元素的索引。若没有找到对应元素则返回-1。
  
      ```js
      const arr = ["菠萝", "苹果", "香蕉", "梨子"];
      const list = List(arr);
      const index = list.findLastIndex((item) => item === "香蕉");//找出数组中元素为"香蕉"的元素下标
      console.log(index); // 2 
      //相信在这里有些小伙伴会出现疑问，为啥和findIndex返回值一样 其实当数组值唯一时，两者几乎没有差别，但是当数组的值很多一样的时候，正序遍历和逆序遍历就有区别了。
      ```
  
  25. **indexOf(searchValue: T): number** `indexOf('searchElement')` 查找元素首次出现在数组的索引 未找到返回-1
  
      ```js
      const arr = ["菠萝", "苹果", "香蕉", "梨子"];
      const list = List(arr);
      const index = list.indexOf("香蕉");//找出数组中元素为"香蕉"的元素下标
      console.log(index); // 2 
      ```
  
  26. **lastIndexOf(searchValue: T): number** `lastIndexOf`查找元素从前往后首次出现在数组的索引 未找到返回-1
  
      ```js
      const arr = ["菠萝","香蕉", "苹果", "香蕉", "梨子"];
      const list = List(arr);
      const index = list.lastIndexOf("香蕉");//找出数组中元素为"香蕉"的元素下标
      console.log(index); // 3 
      ```
  
  27. **keys()** `keys`方法返回一个包含数组中每个索引键的`Array Iterator`对象
  
      ```js
          const arr = ["菠萝", "香蕉", "苹果", "香蕉", "梨子"];
          const list = List(arr);
          const iterator = list.keys();
          for (const item of iterator) {
            console.log(item); // 0 1 2 3 4
          }
      ```
  
  28. **values()** values方法返回一个包含数组中每个索引值的Array Iterator对象
  
      ```js
      const arr = ["菠萝", "香蕉", "苹果", "香蕉", "梨子"];
      const list = List(arr);
      const iterator = list.keys();
      for (const item of iterator) {
         console.log(item); // "菠萝", "香蕉", "苹果", "香蕉", "梨子"
      }
      ```
  
  29. **entries()** `forEach`方法用于遍历数据，与原生方法一样
  
      ```js
      const arr = ["菠萝", "香蕉", "苹果", "香蕉", "梨子"];
      const list = List(arr);
      const iterator = list.keys();
      for (const item of iterator) {
         console.log(item); // [0,"菠萝"][1,"香蕉"][2,"苹果"][3,"香蕉"][4,"梨子"] 
      }
      ```
  
* 练习

```js
const {List} = require('immutable')
const list1 = List([1,2])
const list2 = list1.push(3,4,5)
const list3 = list3.unshift(0)
const list4 = list1.concat(list2,list3)
assert.equal(list1.size, 2); assert.equal(list2.size, 5); assert.equal(list3.size, 6); assert.equal(list4.size, 13); assert.equal(list4.get(0), 1); //push, set, unshift or splice 都可以直接用，返回一个新的immutable对象
```

(3) merge,concat

```js
const {Map,List} = require('immutable')
const map1 = Map({a:1,b:2,c:3,d:4})
const map2 = Map({ c: 10, a: 20, t: 30 }); 
const obj = { d: 100, o: 200, g: 300 };
const map3 = map1.merge(map2,obj)
```

## 5.Immutable+Redux的开发方式

```jsx
// reducer.js
const initalState = fromJS({
    category:'',
    material:''
})
const reducer=(prevState=initalState,action={})=>{
    let {tyle，payload}=action
    switch(type){
        case GET_HOME:
            var newState = prevState.set("category",fromJS(payload.category))
            var newState2=newState.set("material",fromJS(payload.material))
            return newState2;
        default:
            return prevState
    }
}
//home.js 
const mapStateToProps = (state)=>{ 
    return {
        category:state.homeReducer.getIn(["category"]) || Map({}), 
        material:state.homeReducer.getIn(["material"]) || Map({}) 
    } 
}
this.props.category.get("相关属性") this.props.category.toJS() //或者转成普通对象
```

# Mobx

https://cn.mobx.js.org/ 

## 1. Mobx介绍

(1) Mobx是一个功能强大，上手非常容易的状态管理工具。 

(2) Mobx背后的哲学很简单: 任何源自应用状态的东西都应该自动地获得。 

(3) Mobx利用getter和setter来收集组件的数据依赖关系，从而在数据发生变化的时 

候精确知道哪些组件需要重绘，在界面的规模变大的时候，往往会有很多细粒度更新。 

## 2.Mobx与redux的区别

* Mobx写法上更偏向于OOP 
* 对一份数据直接进行修改操作，不需要始终返回一个新的数据 
* 并非单一store,可以多store。 
* Redux默认以JavaScript原生对象形式存储数据，而Mobx使用可观察对象

优点： 

a. 学习成本小 

b. 面向对象编程, 而且对 TS 友好 

缺点： 

a. 过于自由：Mobx提供的约定及模版代码很少，代码编写很自由，如果不做一些约定，比较容易导致团队代码风格不统一， 

b. 相关的中间件很少，逻辑层业务整合是问题。

## 3.Mobx的使用

(1) observable 和 autorun

```js
import {observable,autorun} from 'mobx'
const value = observable.box(0)
const number = observable.box(100)
autorun(()=>{
    console.log(value.get())
})
value.set(1)
value.set(2)
value.set(101)
//0,1,2。 // autorun 使用到才能被执行 //只能是同步，异步需要处理

//观察对象，通过map 
const map = observable.map({ key: "value"}); //map.set("key", "new value"); 
//map.get("key")

//观察对象，不通过map 
const map = observable({ key: "value"}); 
// map.key map.key="xiaoming" 

//观察数组 
const list = observable([1, 2, 4]); 
list[2] = 3;
```

(2) action,runinAction 和严格模式

```js
import {observable,action,configure,runInAction} from 'mobx'
configure({enforceAction:'always'})
// 严格模式 必要写action
// 如果是never 可以不写action
// 最好设置always，防止任意地方修改值，降低不确定性
class Store {
    @observable number=0
    @observable name="Iekika"
    @action add=()=>{
        this.number++
    }//action只能影响正在运行的函数，而无法影响当前函数调用的异步操作
@action load = async () => { 
        const data = await getData(); 
        runInAction(() => { 
                this.name = data.name; }); 
        }// runInAction 解决异步问题 
}
const newStore = new Store(); 
newStore.add(); //如果在组件监听
componentDidMount() { 
    autorun(()=>{ 
        console.log(newStore.number); 
    }) 
}
```

## 4.mobx-react的使用

(1) react 组件里使用 @observer

observer 函数/装饰器可以用来将React组件转变成响应式组件

(2) 可观察的局部组件状态

@observable 装饰器在React组件上引入可观察属性。而不需要通过 React 的冗长和强制性的 setState 机制来管理。 

```js
import {observer} from "mobx-react" 
import {observable} from "mobx"
@observer class Timer extends React.Component {
    @observable secondsPassed = 0 
    componentWillMount() { 
        setInterval(() => { 
            this.secondsPassed++ 
        }, 1000) 
    }
//如果是严格模式需要加上 @action 和 runInAction 
//一个新的生命周期钩子函数 componentWillReact 
//当组件因为它观察的数据发生了改变，它会安排重新渲染， 
//这个时候 componentWillReact 会被触发 
    componentWillReact() { 
    console.log("I will re-render, since the todo has changed!"); 
    }
    render() { 
        return (<span>Seconds passed: {this.secondsPassed } </span> ) 
    } 
}
ReactDOM.render(<Timer />, document.body)
```

（3）Provider 组件 

它使用了 React 的上下文(context)机制，可以用来向下传递 stores。 要连接到这些 stores，需要传递一个 stores 

名称的列表给 inject，这使得 stores 可以作为组件的 props 使用。this.props

```js
class Store { 
    @observable number = 0; 
@action add = () => { this.number++; } 
}
export default new Store() 
//导出Store实例 
@inject("kerwinstore") 
@observer //需要转换为响应式组件 
class Child extends Component{ 
    render(){ 
        return <div> Child --{this.props.kerwinstore.number} </div> 
    } 
}
@inject("kerwinstore") class Middle extends Component{ render(){ 
    return <div> Middle-<button onClick={()=>{ this.props.kerwinstore.add(); }}>test</button>
<Child/> 
        </div> 
} 
}//通过provider传store进去 
<Provider kerwinstore={store}> 
    <Middle/> 
 </Provider>
```

## 5.支持装饰器

```ssh
npm i @babel/core @babel/plugin-proposal-decorators @babel/preset-env
```

**创建 .babelrc**

```json
{ 
    "presets": [ 
        "@babel/preset-env" 
               ],
    "plugins": [ 
        [ "@babel/plugin-proposal-decorators", 
         { "legacy": true } 
        ] 
    ] 
}
```

**创建confifig-overrides.js**

```js
const path = require('path') 
const { override, addDecoratorsLegacy } = require('customize-cra') 
function resolve(dir) { 
    return path.join(__dirname, dir) }
const customize = () => (config, env) => { 
    config.resolve.alias['@'] = resolve('src')
    if (env === 'production') { 
        config.externals = { 'react': 'React', 'react-dom': 'ReactDOM' } 
    }
    return config };
module.exports = override(addDecoratorsLegacy(), customize())
```

**安装依赖**

```ssh
npm i customize-cra react-app-rewired
```

**修改package.json**

```json
...
"scripts": { 
    "start": "react-app-rewired start", 
    "build": "react-app-rewired build",
    "test": "react-app-rewired test", 
    "eject": "react-app-rewired eject" 
},
...
```

# TS

## 1. typescript












